---
title: server
head.title: 'server/'
description: Thư mục server/ được sử dụng để đăng ký các API và server handler cho ứng dụng của bạn.
navigation.icon: i-lucide-folder
---

Nuxt tự động quét các file trong những thư mục này để đăng ký API và server handler với hỗ trợ Hot Module Replacement (HMR).

```bash [Directory structure]
-| server/
---| api/
-----| hello.ts      # /api/hello
---| routes/
-----| bonjour.ts    # /bonjour
---| middleware/
-----| log.ts        # log all requests
```

Mỗi file nên export một function mặc định được định nghĩa bằng `defineEventHandler()` hoặc `eventHandler()` (alias).

Handler có thể trực tiếp trả về dữ liệu JSON, một `Promise`, hoặc sử dụng `event.node.res.end()` để gửi response.

```ts twoslash [server/api/hello.ts]
export default defineEventHandler((event) => {
  return {
    hello: 'world'
  }
})
```

Giờ bạn có thể gọi API này universally trong pages và components:

```vue [pages/index.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/hello')
</script>

<template>
  <pre>{{ data }}</pre>
</template>
```

## Server Routes

Các file trong `~/server/api` được tự động thêm tiền tố `/api` vào route.

:video-accordion{title="Xem video từ Vue School về API routes" videoId="761468863" platform="vimeo"}

Để thêm server routes mà không có tiền tố `/api`, đặt chúng vào thư mục `~/server/routes`.

**Ví dụ:**

```ts [server/routes/hello.ts]
export default defineEventHandler(() => 'Hello World!')
```

Với ví dụ trên, route `/hello` sẽ có thể truy cập tại <http://localhost:3000/hello>.

::note
Lưu ý rằng hiện tại server routes không hỗ trợ đầy đủ chức năng của dynamic routes như [pages](/docs/guide/directory-structure/pages#dynamic-routes).
::

## Server Middleware

Nuxt sẽ tự động đọc bất kỳ file nào trong `~/server/middleware` để tạo server middleware cho dự án của bạn.

Middleware handlers sẽ chạy trên mỗi request trước bất kỳ server route nào khác để thêm hoặc kiểm tra headers, log requests, hoặc mở rộng request object của event.

::note
Middleware handlers không nên trả về bất cứ thứ gì (cũng như không đóng hoặc respond request) và chỉ nên kiểm tra hoặc mở rộng request context hoặc throw error.
::

**Ví dụ:**

```ts [server/middleware/log.ts]
export default defineEventHandler((event) => {
  console.log('New request: ' + getRequestURL(event))
})
```

```ts [server/middleware/auth.ts]
export default defineEventHandler((event) => {
  event.context.auth = { user: 123 }
})
```

## Server Plugins

Nuxt sẽ tự động đọc bất kỳ file nào trong thư mục `~/server/plugins` và đăng ký chúng như Nitro plugins. Điều này cho phép mở rộng runtime behavior của Nitro và hook vào lifecycle events.

**Ví dụ:**

```ts [server/plugins/nitroPlugin.ts]
export default defineNitroPlugin((nitroApp) => {
  console.log('Nitro plugin', nitroApp)
})
```

:read-more{to="https://nitro.build/guide/plugins" title="Nitro Plugins" target="_blank"}

## Server Utilities

Server routes được cung cấp bởi [h3js/h3](https://github.com/h3js/h3) có kèm một bộ helpers hữu ích.

:read-more{to="https://www.jsdocs.io/package/h3#package-index-functions" title="Available H3 Request Helpers" target="_blank"}

Bạn có thể thêm nhiều helpers khác trong thư mục `~/server/utils`.

Ví dụ, bạn có thể định nghĩa một custom handler utility bao bọc original handler và thực hiện các thao tác bổ sung trước khi trả về final response.

**Ví dụ:**

```ts [server/utils/handler.ts]
import type { EventHandler, EventHandlerRequest } from 'h3'

export const defineWrappedResponseHandler = <T extends EventHandlerRequest, D> (
  handler: EventHandler<T, D>
): EventHandler<T, D> =>
  defineEventHandler<T>(async event => {
    try {
      // do something before the route handler
      const response = await handler(event)
      // do something after the route handler
      return { response }
    } catch (err) {
      // Error handling
      return { err }
    }
  })
```

## Server Types

::tip
Tính năng này có sẵn từ Nuxt >= 3.5
::

## Recipes

### Route Parameters

Server routes có thể sử dụng dynamic parameters trong dấu ngoặc vuông trong tên file như `/api/hello/[name].ts` và được truy cập qua `event.context.params`.

```ts [server/api/hello/[name\\].ts]
export default defineEventHandler((event) => {
  const name = getRouterParam(event, 'name')

  return `Hello, ${name}!`
})
```

::tip{to="https://h3.dev/examples/validate-data#validate-params"}
Thay vào đó, sử dụng `getValidatedRouterParams` với một schema validator như Zod cho runtime và type safety.
::

Giờ bạn có thể gọi API này universally trên `/api/hello/nuxt` và nhận `Hello, nuxt!`.

### Matching HTTP Method

Tên file handler có thể có hậu tố `.get`, `.post`, `.put`, `.delete`, ... để match với [HTTP Method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) của request.

```ts [server/api/test.get.ts]
export default defineEventHandler(() => 'Test get handler')
```

```ts [server/api/test.post.ts]
export default defineEventHandler(() => 'Test post handler')
```

Với ví dụ trên, fetch `/test` với:

- **GET** method: Trả về `Test get handler`
- **POST** method: Trả về `Test post handler`
- Bất kỳ method nào khác: Trả về lỗi 405

Bạn cũng có thể sử dụng `index.[method].ts` trong một thư mục để cấu trúc code khác biệt, điều này hữu ích để tạo API namespaces.

::code-group
```ts [server/api/foo/index.get.ts]
export default defineEventHandler((event) => {
  // handle GET requests for the `api/foo` endpoint
})
```
```ts [server/api/foo/index.post.ts]
export default defineEventHandler((event) => {
  // handle POST requests for the `api/foo` endpoint
})
```
```ts [server/api/foo/bar.get.ts]
export default defineEventHandler((event) => {
  // handle GET requests for the `api/foo/bar` endpoint
})
```
::

### Catch-all Route

Catch-all routes hữu ích cho việc xử lý fallback route.

Ví dụ, tạo một file có tên `~/server/api/foo/[...].ts` sẽ đăng ký một catch-all route cho tất cả requests không match với bất kỳ route handler nào, chẳng hạn như `/api/foo/bar/baz`.

```ts [server/api/foo/[...\\].ts]
export default defineEventHandler((event) => {
  // event.context.path để lấy route path: '/api/foo/bar/baz'
  // event.context.params._ để lấy route segment: 'bar/baz'
  return `Default foo handler`
})
```

Bạn có thể đặt tên cho catch-all route bằng cách sử dụng `~/server/api/foo/[...slug].ts` và truy cập qua `event.context.params.slug`.

```ts [server/api/foo/[...slug\\].ts]
export default defineEventHandler((event) => {
  // event.context.params.slug để lấy route segment: 'bar/baz'
  return `Default foo handler`
})
```

### Body Handling

```ts [server/api/submit.post.ts]
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  return { body }
})
```

::tip{to="https://unjs.io/blog/2023-08-15-h3-towards-the-edge-of-the-web#runtime-type-safe-request-utils"}
Thay vào đó, sử dụng `readValidatedBody` với một schema validator như Zod cho runtime và type safety.
::

Giờ bạn có thể gọi API này universally bằng cách sử dụng:

```vue [app.vue]
<script setup lang="ts">
async function submit() {
  const { body } = await $fetch('/api/submit', {
    method: 'post',
    body: { test: 123 }
  })
}
</script>
```

::note
Chúng tôi sử dụng `submit.post.ts` trong tên file chỉ để match requests với `POST` method có thể chấp nhận request body. Khi sử dụng `readBody` trong GET request, `readBody` sẽ throw một `405 Method Not Allowed` HTTP error.
::

### Query Parameters

Sample query `/api/query?foo=bar&baz=qux`

```ts [server/api/query.get.ts]
export default defineEventHandler((event) => {
  const query = getQuery(event)

  return { a: query.foo, b: query.baz }
})
```

::tip{to="https://unjs.io/blog/2023-08-15-h3-towards-the-edge-of-the-web#runtime-type-safe-request-utils"}
Thay vào đó, sử dụng `getValidatedQuery` với một schema validator như Zod cho runtime và type safety.
::

### Error Handling

Nếu không có error nào được throw, status code `200 OK` sẽ được trả về.

Bất kỳ uncaught error nào sẽ trả về `500 Internal Server Error` HTTP Error.

Để trả về error codes khác, throw một exception với [`createError`](/docs/api/utils/create-error):

```ts [server/api/validation/[id\\].ts]
export default defineEventHandler((event) => {
  const id = parseInt(event.context.params.id) as number

  if (!Number.isInteger(id)) {
    throw createError({
      statusCode: 400,
      statusMessage: 'ID should be an integer',
    })
  }
  return 'All good'
})
```

### Status Codes

Để trả về status codes khác, sử dụng utility [`setResponseStatus`](/docs/api/utils/set-response-status).

Ví dụ, để trả về `202 Accepted`

```ts [server/api/validation/[id\\].ts]
export default defineEventHandler((event) => {
  setResponseStatus(event, 202)
})
```

### Runtime Config

::code-group
```ts [server/api/foo.ts]
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig(event)

  const repo = await $fetch('https://api.github.com/repos/nuxt/nuxt', {
    headers: {
      Authorization: `token ${config.githubToken}`
    }
  })

  return repo
})
```
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    githubToken: ''
  }
})
```
```ini [.env]
NUXT_GITHUB_TOKEN='<my-super-token>'
```
::

::note
Cung cấp `event` như argument cho `useRuntimeConfig` là tùy chọn, nhưng được khuyến nghị pass nó để lấy runtime config bị ghi đè bởi [environment variables](/docs/guide/going-further/runtime-config#environment-variables) tại runtime cho server routes.
::

### Request Cookies

```ts [server/api/cookies.ts]
export default defineEventHandler((event) => {
  const cookies = parseCookies(event)

  return { cookies }
})
```

### Forwarding Context & Headers

Theo mặc định, không có headers nào từ incoming request hoặc request context được forward khi thực hiện fetch requests trong server routes. Bạn có thể sử dụng `event.$fetch` để forward request context và headers khi thực hiện fetch requests trong server routes.

```ts [server/api/forward.ts]
export default defineEventHandler((event) => {
  return event.$fetch('/api/forwarded')
})
```

::note
Các headers **không được có ý định forward** sẽ **không được bao gồm** trong request. Những headers này bao gồm, ví dụ:
`transfer-encoding`, `connection`, `keep-alive`, `upgrade`, `expect`, `host`, `accept`
::

### Awaiting Promises After Response

Khi xử lý server requests, bạn có thể cần thực hiện các async tasks không nên block response tới client (ví dụ, caching và logging). Bạn có thể sử dụng `event.waitUntil` để await một promise trong background mà không làm trễ response.

Method `event.waitUntil` chấp nhận một promise sẽ được awaited trước khi handler terminate, đảm bảo task được hoàn thành ngay cả khi server sẽ terminate handler ngay sau khi response được gửi. Điều này tích hợp với runtime providers để tận dụng native capabilities của chúng để xử lý asynchronous operations sau khi response được gửi.

```ts [server/api/background-task.ts]
const timeConsumingBackgroundTask = async () => {
  await new Promise((resolve) => setTimeout(resolve, 1000))
};

export default eventHandler((event) => {
  // schedule a background task without blocking the response
  event.waitUntil(timeConsumingBackgroundTask())

  // immediately send the response to the client
  return 'done'
});
```

## Advanced Usage

### Nitro Config

Bạn có thể sử dụng key `nitro` trong `nuxt.config` để trực tiếp set [Nitro configuration](https://nitro.build/config).

::warning
Đây là một tùy chọn nâng cao. Custom config có thể ảnh hưởng đến production deployments, vì configuration interface có thể thay đổi theo thời gian khi Nitro được upgrade trong semver-minor versions của Nuxt.
::

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // https://nitro.build/config
  nitro: {}
})
```

:read-more{to="/docs/guide/concepts/server-engine"}

### Nested Router

```ts [server/api/hello/[...slug\\].ts]
import { createRouter, defineEventHandler, useBase } from 'h3'

const router = createRouter()

router.get('/test', defineEventHandler(() => 'Hello World'))

export default useBase('/api/hello', router.handler)
```

### Sending Streams

::tip
Đây là một experimental feature và có sẵn trong tất cả environments.
::

```ts [server/api/foo.get.ts]
import fs from 'node:fs'
import { sendStream } from 'h3'

export default defineEventHandler((event) => {
  return sendStream(event, fs.createReadStream('/path/to/file'))
})
```

### Sending Redirect

```ts [server/api/foo.get.ts]
export default defineEventHandler(async (event) => {
  await sendRedirect(event, '/path/redirect/to', 302)
})
```

### Legacy Handler or Middleware

```ts [server/api/legacy.ts]
export default fromNodeMiddleware((req, res) => {
  res.end('Legacy handler')
})
```

::important
Legacy support có thể sử dụng [h3js/h3](https://github.com/h3js/h3), nhưng được khuyên tránh legacy handlers càng nhiều càng tốt.
::

```ts [server/middleware/legacy.ts]
export default fromNodeMiddleware((req, res, next) => {
  console.log('Legacy middleware')
  next()
})
```

::warning
Không bao giờ kết hợp `next()` callback với legacy middleware là `async` hoặc trả về một `Promise`.
::

### Server Storage

Nitro cung cấp một cross-platform [storage layer](https://nitro.build/guide/storage). Để cấu hình các storage mount points bổ sung, bạn có thể sử dụng `nitro.storage`, hoặc [server plugins](#server-plugins).

**Ví dụ thêm Redis storage:**

Sử dụng `nitro.storage`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    storage: {
      redis: {
        driver: 'redis',
        /* redis connector options */
        port: 6379, // Redis port
        host: "127.0.0.1", // Redis host
        username: "", // needs Redis >= 6
        password: "",
        db: 0, // Defaults to 0
        tls: {} // tls/ssl
      }
    }
  }
})
```

Sau đó trong API handler:

```ts [server/api/storage/test.ts]
export default defineEventHandler(async (event) => {
  // List all keys with
  const keys = await useStorage('redis').getKeys()

  // Set a key with
  await useStorage('redis').setItem('foo', 'bar')

  // Remove a key with
  await useStorage('redis').removeItem('foo')

  return {}
})
```

::read-more{to="https://nitro.build/guide/storage" target="_blank"}
Đọc thêm về Nitro Storage Layer.
::

Thay vào đó, bạn có thể tạo một storage mount point sử dụng server plugin và runtime config:

::code-group
```ts [server/plugins/storage.ts]
import redisDriver from 'unstorage/drivers/redis'

export default defineNitroPlugin(() => {
  const storage = useStorage()

  // Dynamically pass in credentials from runtime configuration, or other sources
  const driver = redisDriver({
      base: 'redis',
      host: useRuntimeConfig().redis.host,
      port: useRuntimeConfig().redis.port,
      /* other redis connector options */
    })

  // Mount driver
  storage.mount('redis', driver)
})
```

``` ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    redis: { // Default values
      host: '',
      port: 0,
      /* other redis connector options */
    }
  }
})
```
::