---
title: "components"
head.title: "components/"
description: "The components/ directory is where you put all your Vue components."
navigation.icon: i-lucide-folder
---

Nuxt tự động nhập bất kỳ component nào trong thư mục này (cùng với các component được đăng ký bởi bất kỳ module nào bạn có thể đang sử dụng).

```bash [Directory Structure]
-| components/
---| AppHeader.vue
---| AppFooter.vue
```

```html [app.vue]
<template>
  <div>
    <AppHeader />
    <NuxtPage />
    <AppFooter />
  </div>
</template>
```

## Component Names

Nếu bạn có một component trong các thư mục lồng nhau như:

```bash [Directory Structure]
-| components/
---| base/
-----| foo/
-------| Button.vue
```

... thì tên của component sẽ dựa trên đường dẫn thư mục và tên tệp của chính nó, với các đoạn trùng lặp được loại bỏ. Do đó, tên của component sẽ là:

```html
<BaseFooButton />
```

::note
Để rõ ràng, chúng tôi khuyên rằng tên tệp của component nên khớp với tên của nó. Vì vậy, trong ví dụ trên, bạn có thể đổi tên `Button.vue` thành `BaseFooButton.vue`.
::

Nếu bạn muốn tự động nhập các component chỉ dựa trên tên của nó, không phải đường dẫn, thì bạn cần đặt tùy chọn `pathPrefix` thành `false` bằng cách sử dụng dạng mở rộng của đối tượng cấu hình:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  components: [
    {
      path: '~/components',
      pathPrefix: false, // [!code ++]
    },
  ],
});
```

Điều này đăng ký các component bằng cách sử dụng cùng chiến lược như được sử dụng trong Nuxt 2. Ví dụ, `~/components/Some/MyComponent.vue` sẽ có thể sử dụng được dưới dạng `<MyComponent>` chứ không phải `<SomeMyComponent>`.

## Dynamic Components

Nếu bạn muốn sử dụng cú pháp Vue `<component :is="someComputedComponent">`{lang=vue}, bạn cần sử dụng helper `resolveComponent` được cung cấp bởi Vue hoặc nhập component trực tiếp từ `#components` và truyền nó vào prop `is`.

Ví dụ:

```vue [pages/index.vue]
<script setup lang="ts">
import { SomeComponent } from '#components'

const MyButton = resolveComponent('MyButton')
</script>

<template>
  <component :is="clickable ? MyButton : 'div'" />
  <component :is="SomeComponent" />
</template>
```

::important
Nếu bạn đang sử dụng `resolveComponent` để xử lý các component động, hãy đảm bảo không chèn bất cứ thứ gì ngoài tên của component, tên này phải là một chuỗi ký tự theo nghĩa đen và không phải là hoặc chứa một biến. Chuỗi được phân tích tĩnh tại bước biên dịch.
::

:video-accordion{title="Xem video ngắn của Daniel Roe về resolveComponent()" videoId="4kq8E5IUM2U"}

Ngoài ra, mặc dù không được khuyến nghị, bạn có thể đăng ký tất cả các component của mình toàn cục, điều này sẽ tạo ra các chunk async cho tất cả các component của bạn và làm cho chúng có sẵn trong toàn bộ ứng dụng của bạn.

```diff
  export default defineNuxtConfig({
    components: {
+     global: true,
+     dirs: ['~/components']
    },
  })
```

Bạn cũng có thể đăng ký có chọn lọc một số component toàn cục bằng cách đặt chúng trong thư mục `~/components/global`, hoặc bằng cách sử dụng hậu tố `.global.vue` trong tên tệp. Như đã lưu ý ở trên, mỗi component toàn cục được render trong một chunk riêng biệt, vì vậy hãy cẩn thận không lạm dụng tính năng này.

::note
Tùy chọn `global` cũng có thể được đặt cho mỗi thư mục component.
::

## Dynamic Imports

Để nhập động một component (cũng được gọi là lazy-loading một component), tất cả những gì bạn cần làm là thêm tiền tố `Lazy` vào tên của component. Điều này đặc biệt hữu ích nếu component không luôn được cần đến.

Bằng cách sử dụng tiền tố `Lazy`, bạn có thể trì hoãn việc tải mã component cho đến thời điểm phù hợp, điều này có thể hữu ích để tối ưu hóa kích thước bundle JavaScript của bạn.

```vue [pages/index.vue]
<script setup lang="ts">
const show = ref(false)
</script>

<template>
  <div>
    <h1>Mountains</h1>
    <LazyMountainsList v-if="show" />
    <button v-if="!show" @click="show = true">Show List</button>
  </div>
</template>
```

## Delayed (or Lazy) Hydration

Các component lazy rất tuyệt vời để kiểm soát kích thước chunk trong ứng dụng của bạn, nhưng chúng không luôn cải thiện hiệu suất runtime, vì chúng vẫn tải eagerly trừ khi được render có điều kiện. Trong các ứng dụng thực tế, một số trang có thể bao gồm nhiều nội dung và nhiều component, và hầu hết thời gian không phải tất cả chúng đều cần tương tác ngay khi trang được tải. Việc tải tất cả chúng eagerly có thể ảnh hưởng tiêu cực đến hiệu suất.

Để tối ưu hóa ứng dụng của bạn, bạn có thể muốn trì hoãn hydration của một số component cho đến khi chúng hiển thị, hoặc cho đến khi trình duyệt hoàn thành các tác vụ quan trọng hơn.

Nuxt hỗ trợ điều này bằng cách sử dụng lazy (hoặc delayed) hydration, cho phép bạn kiểm soát khi nào các component trở nên tương tác.

### Hydration Strategies

Nuxt cung cấp một loạt các chiến lược hydration tích hợp. Chỉ một chiến lược có thể được sử dụng cho mỗi component lazy.

::warning
Hiện tại, lazy hydration tích hợp của Nuxt chỉ hoạt động trong các component tệp đơn (SFCs), và yêu cầu bạn định nghĩa prop trong template (thay vì spread một đối tượng props qua `v-bind`). Nó cũng không hoạt động với các import trực tiếp từ `#components`.
::

#### `hydrate-on-visible`

Hydrate component khi nó trở nên hiển thị trong viewport.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-visible />
  </div>
</template>
```

:read-more{to="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver" title="IntersectionObserver options"}
Đọc thêm về các tùy chọn cho `hydrate-on-visible`.
::

::note
Bên dưới, điều này sử dụng chiến lược [`hydrateOnVisible` tích hợp của Vue](https://vuejs.org/guide/components/async.html#hydrate-on-visible).
::

#### `hydrate-on-idle`

Hydrate component khi trình duyệt ở trạng thái idle. Điều này phù hợp nếu bạn cần component tải càng sớm càng tốt, nhưng không chặn đường dẫn render quan trọng.

Bạn cũng có thể truyền một số đóng vai trò là timeout tối đa.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-idle />
  </div>
</template>
```

::note
Bên dưới, điều này sử dụng chiến lược [`hydrateOnIdle` tích hợp của Vue](https://vuejs.org/guide/components/async.html#hydrate-on-idle).
::

#### `hydrate-on-interaction`

Hydrate component sau một tương tác được chỉ định (ví dụ: click, mouseover).

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-interaction="mouseover" />
  </div>
</template>
```

Nếu bạn không truyền một sự kiện hoặc danh sách sự kiện, nó mặc định hydrate trên `pointerenter`, `click` và `focus`.

::note
Bên dưới, điều này sử dụng chiến lược [`hydrateOnInteraction` tích hợp của Vue](https://vuejs.org/guide/components/async.html#hydrate-on-interaction).
::

#### `hydrate-on-media-query`

Hydrate component khi cửa sổ khớp với một media query.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-media-query="(max-width: 768px)" />
  </div>
</template>
```

::note
Bên dưới, điều này sử dụng chiến lược [`hydrateOnMediaQuery` tích hợp của Vue](https://vuejs.org/guide/components/async.html#hydrate-on-media-query).
::

#### `hydrate-after`

Hydrate component sau một độ trễ được chỉ định (tính bằng mili giây).

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent :hydrate-after="2000" />
  </div>
</template>
```

#### `hydrate-when`

Hydrate component dựa trên một điều kiện boolean.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent :hydrate-when="isReady" />
  </div>
</template>
<script setup lang="ts">
const isReady = ref(false)
function myFunction() {
  // trigger custom hydration strategy...
  isReady.value = true
}
</script>
```

#### `hydrate-never`

Không bao giờ hydrate component.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-never />
  </div>
</template>
```

### Listening to Hydration Events

Tất cả các component hydration bị trì hoãn phát ra sự kiện `@hydrated` khi chúng được hydrate.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-visible @hydrated="onHydrate" />
  </div>
</template>

<script setup lang="ts">
function onHydrate() {
  console.log("Component has been hydrated!")
}
</script>
```

### Caveats and Best Practices

Hydration bị trì hoãn có thể mang lại lợi ích về hiệu suất, nhưng việc sử dụng đúng cách là rất quan trọng:

1. **Ưu tiên Nội dung Trong Viewport:** Tránh hydration bị trì hoãn cho nội dung quan trọng, above-the-fold. Nó phù hợp nhất cho nội dung không cần ngay lập tức.

2. **Render Có Điều kiện:** Khi sử dụng `v-if="false"` trên một component lazy, bạn có thể không cần hydration bị trì hoãn. Bạn chỉ cần sử dụng một component lazy bình thường.

3. **Trạng thái Chia sẻ:** Hãy chú ý đến trạng thái chia sẻ (`v-model`) trên nhiều component. Việc cập nhật model trong một component có thể kích hoạt hydration trong tất cả các component được bind với model đó.

4. **Sử dụng Trường hợp Dự định của Mỗi Chiến lược:** Mỗi chiến lược được tối ưu hóa cho một mục đích cụ thể.
   * `hydrate-when` tốt nhất cho các component có thể không luôn cần được hydrate.
   * `hydrate-after` dành cho các component có thể chờ một khoảng thời gian cụ thể.
   * `hydrate-on-idle` dành cho các component có thể được hydrate khi trình duyệt ở trạng thái idle.

5. **Tránh `hydrate-never` trên các component tương tác:** Nếu một component yêu cầu tương tác của người dùng, nó không nên được đặt thành never hydrate.

## Direct Imports

Bạn cũng có thể nhập rõ ràng các component từ `#components` nếu bạn muốn hoặc cần bỏ qua chức năng tự động nhập của Nuxt.

```vue [pages/index.vue]
<script setup lang="ts">
import { NuxtLink, LazyMountainsList } from '#components'

const show = ref(false)
</script>

<template>
  <div>
    <h1>Mountains</h1>
    <LazyMountainsList v-if="show" />
    <button v-if="!show" @click="show = true">Show List</button>
    <NuxtLink to="/">Home</NuxtLink>
  </div>
</template>
```

## Custom Directories

Theo mặc định, chỉ thư mục `~/components` được quét. Nếu bạn muốn thêm các thư mục khác, hoặc thay đổi cách các component được quét trong một thư mục con của thư mục này, bạn có thể thêm các thư mục bổ sung vào cấu hình:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  components: [
    // ~/calendar-module/components/event/Update.vue => <EventUpdate />
    { path: '~/calendar-module/components' },

    // ~/user-module/components/account/UserDeleteDialog.vue => <UserDeleteDialog />
    { path: '~/user-module/components', pathPrefix: false },

    // ~/components/special-components/Btn.vue => <SpecialBtn />
    { path: '~/components/special-components', prefix: 'Special' },

    // It's important that this comes last if you have overrides you wish to apply
    // to sub-directories of `~/components`.
    //
    // ~/components/Btn.vue => <Btn />
    // ~/components/base/Btn.vue => <BaseBtn />
    '~/components'
  ]
})
```

::note
Bất kỳ thư mục lồng nhau nào cần được thêm trước vì chúng được quét theo thứ tự.
::

## npm Packages

Nếu bạn muốn tự động nhập các component từ một gói npm, bạn có thể sử dụng [`addComponent`](/docs/api/kit/components#addcomponent) trong một [module cục bộ](/docs/guide/directory-structure/modules) để đăng ký chúng.

::code-group

```ts twoslash [~/modules/register-component.ts]
import { addComponent, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    // import { MyComponent as MyAutoImportedComponent } from 'my-npm-package'
    addComponent({
      name: 'MyAutoImportedComponent',
      export: 'MyComponent',
      filePath: 'my-npm-package',
    })
  },
})
```

```vue [app.vue]
<template>
  <div>
    <!--  the component uses the name we specified and is auto-imported  -->
    <MyAutoImportedComponent />
  </div>
</template>
```

::

## Component Extensions

Theo mặc định, bất kỳ tệp nào có phần mở rộng được chỉ định trong [khóa extensions của `nuxt.config.ts`](/docs/api/nuxt-config#extensions) được coi là một component.
Nếu bạn cần hạn chế các phần mở rộng tệp nên được đăng ký làm component, bạn có thể sử dụng dạng mở rộng của khai báo thư mục component và khóa `extensions` của nó:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  components: [
    {
      path: '~/components',
      extensions: ['.vue'], // [!code ++]
    }
  ]
})
```

## Client Components

Nếu một component được thiết kế để chỉ render ở phía client, bạn có thể thêm hậu tố `.client` vào component của mình.

```bash [Directory Structure]
| components/
--| Comments.client.vue
```

```vue [pages/example.vue]
<template>
  <div>
    <!-- this component will only be rendered on client side -->
    <Comments />
  </div>
</template>
```

::note
Tính năng này chỉ hoạt động với auto-imports của Nuxt và imports `#components`. Việc nhập rõ ràng các component này từ đường dẫn thực của chúng không chuyển đổi chúng thành các component chỉ client.
::

::important
Các component `.client` chỉ được render sau khi được mount. Để truy cập template đã render bằng `onMounted()`, hãy thêm `await nextTick()` trong callback của hook `onMounted()`.
::

:read-more{to="/docs/api/components/client-only"}
Bạn cũng có thể đạt được kết quả tương tự với component `<ClientOnly>`.
::

## Server Components

Các component server cho phép server-rendering các component riêng lẻ trong ứng dụng client-side của bạn. Có thể sử dụng các component server trong Nuxt, ngay cả khi bạn đang tạo một trang web tĩnh. Điều đó làm cho việc xây dựng các trang web phức tạp kết hợp các component động, HTML được render server và thậm chí các chunk markup tĩnh trở nên khả thi.

:video-accordion{title="Xem video Learn Vue về Nuxt Server Components" videoId="u1yyXe86xJM"}

::tip{icon="i-lucide-newspaper" to="https://roe.dev/blog/nuxt-server-components" target="_blank"}
Đọc hướng dẫn của Daniel Roe về Nuxt Server Components.
::

### Standalone server components

Các component server độc lập sẽ luôn được render trên server, cũng được gọi là các component Islands.

Khi props của chúng cập nhật, điều này sẽ dẫn đến một yêu cầu mạng sẽ cập nhật HTML đã render ngay tại chỗ.

Các component server hiện tại đang thử nghiệm và để sử dụng chúng, bạn cần bật tính năng 'component islands' trong nuxt.config của mình:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    componentIslands: true
  }
})
```

Bây giờ bạn có thể đăng ký các component chỉ server với hậu tố `.server` và sử dụng chúng ở bất kỳ đâu trong ứng dụng của mình một cách tự động.

```bash [Directory Structure]
-| components/
---| HighlightedMarkdown.server.vue
```

```vue [pages/example.vue]
<template>
  <div>
    <!--
      this will automatically be rendered on the server, meaning your markdown parsing + highlighting
      libraries are not included in your client bundle.
     -->
    <HighlightedMarkdown markdown="# Headline" />
  </div>
</template>
```

Các component chỉ server sử dụng [`<NuxtIsland>`](/docs/api/components/nuxt-island) bên dưới, nghĩa là prop `lazy` và slot `#fallback` đều được truyền xuống nó.

::warning
Các component server (và islands) phải có một phần tử gốc duy nhất. (Các comment HTML cũng được coi là phần tử.)
::

::warning
Props được truyền đến các component server qua các tham số truy vấn URL, và do đó bị giới hạn bởi độ dài có thể của URL, vì vậy hãy cẩn thận không truyền lượng dữ liệu khổng lồ đến các component server qua props.
::

::warning
Hãy cẩn thận khi lồng các islands trong các islands khác vì mỗi island thêm một số overhead bổ sung.
::

::warning
Hầu hết các tính năng cho các component chỉ server và component island, chẳng hạn như slots và client components, chỉ có sẵn cho các component tệp đơn.
::

#### Client components within server components

::note
Tính năng này cần `experimental.componentIslands.selectiveClient` trong cấu hình của bạn được đặt thành true.
::

Bạn có thể hydrate một phần component bằng cách đặt thuộc tính `nuxt-client` trên component bạn muốn tải ở phía client.

```vue [components/ServerWithClient.vue]
<template>
  <div>
    <HighlightedMarkdown markdown="# Headline" />
    <!-- Counter will be loaded and hydrated client-side -->
    <Counter nuxt-client :count="5" />
  </div>
</template>
```

::note
Điều này chỉ hoạt động trong một component server. Các slot cho client components chỉ hoạt động với `experimental.componentIsland.selectiveClient` được đặt thành `'deep'` và vì chúng được render server-side, chúng không tương tác một khi ở phía client.
::

#### Server Component Context

Khi render một component chỉ server hoặc island, `<NuxtIsland>` thực hiện một yêu cầu fetch trả về một `NuxtIslandResponse`. (Đây là một yêu cầu nội bộ nếu được render trên server, hoặc một yêu cầu bạn có thể thấy trong tab network nếu đang render trên navigation phía client.)

Điều này có nghĩa là:

* Một ứng dụng Vue mới sẽ được tạo server-side để tạo `NuxtIslandResponse`.
* Một 'island context' mới sẽ được tạo trong khi render component.
* Bạn không thể truy cập 'island context' từ phần còn lại của ứng dụng và bạn không thể truy cập context của phần còn lại của ứng dụng từ component island. Nói cách khác, component server hoặc island được _cô lập_ khỏi phần còn lại của ứng dụng.
* Các plugin của bạn sẽ chạy lại khi render island, trừ khi chúng có `env: { islands: false }` được đặt (mà bạn có thể làm trong một plugin cú pháp đối tượng).

Trong một component island, bạn có thể truy cập island context của nó qua `nuxtApp.ssrContext.islandContext`. Lưu ý rằng trong khi các component island vẫn được đánh dấu là thử nghiệm, định dạng của context này có thể thay đổi.

::note
Các slot có thể tương tác và được wrap trong một `<div>` với `display: contents;`
::

### Paired with a Client component

Trong trường hợp này, các component `.server` + `.client` là hai 'nửa' của một component và có thể được sử dụng trong các trường hợp sử dụng nâng cao cho việc triển khai riêng biệt của một component ở phía server và client.

```bash [Directory Structure]
-| components/
---| Comments.client.vue
---| Comments.server.vue
```

```vue [pages/example.vue]
<template>
  <div>
    <!-- this component will render Comments.server on the server then Comments.client once mounted in the browser -->
    <Comments />
  </div>
</template>
```

## Built-In Nuxt Components

Có một số component mà Nuxt cung cấp, bao gồm `<ClientOnly>` và `<DevOnly>`. Bạn có thể đọc thêm về chúng trong tài liệu API.

::read-more{to="/docs/api"}
::

## Library Authors

Việc tạo các thư viện component Vue với tree-shaking tự động và đăng ký component rất dễ dàng. ✨

Bạn có thể sử dụng phương thức [`addComponentsDir`](/docs/api/kit/components#addcomponentsdir) được cung cấp từ `@nuxt/kit` để đăng ký thư mục component của bạn trong module Nuxt.

Hãy tưởng tượng một cấu trúc thư mục như thế này:

```bash [Directory Structure]
-| node_modules/
---| awesome-ui/
-----| components/
-------| Alert.vue
-------| Button.vue
-----| nuxt.ts
-| pages/
---| index.vue
-| nuxt.config.ts
```

Sau đó trong `awesome-ui/nuxt.ts` bạn có thể sử dụng hook `addComponentsDir`:

```ts twoslash
import { createResolver, defineNuxtModule, addComponentsDir } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    const resolver = createResolver(import.meta.url)

    // Add ./components dir to the list
    addComponentsDir({
      path: resolver.resolve('./components'),
      prefix: 'awesome',
    })
  },
})
```

Đó là nó! Bây giờ trong dự án của bạn, bạn có thể nhập thư viện UI của mình dưới dạng một module Nuxt trong tệp `nuxt.config` của mình:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['awesome-ui/nuxt']
})
```

... và sử dụng trực tiếp các component module (có tiền tố `awesome-`) trong `pages/index.vue` của chúng ta:

```vue
<template>
  <div>
    My <AwesomeButton>UI button</AwesomeButton>!
    <awesome-alert>Here's an alert!</awesome-alert>
  </div>
</template>
```

Nó sẽ tự động nhập các component chỉ khi được sử dụng và cũng hỗ trợ HMR khi cập nhật các component của bạn trong `node_modules/awesome-ui/components/`.

:link-example{to="/docs/examples/features/auto-imports"}