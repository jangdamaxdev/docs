---
navigation.title: 'Custom useFetch'
title: Custom useFetch in Nuxt
description: How to create a custom fetcher for calling your external API in Nuxt.
---

Khi working với Nuxt, bạn might be making frontend và fetching một external API, và bạn might want để set một số default options cho fetching từ API của bạn.

[`$fetch`](/docs/api/utils/dollarfetch) utility function (used bởi [`useFetch`](/docs/api/composables/use-fetch) composable) is intentionally not globally configurable. Điều này is important so rằng fetching behavior throughout application của bạn remains consistent, và other integrations (like modules) có thể rely trên behavior của core utilities like `$fetch`.

Tuy nhiên, Nuxt provides một way để create một custom fetcher cho API của bạn (hoặc multiple fetchers nếu bạn have multiple APIs để call).

## Custom `$fetch`

Hãy create một custom `$fetch` instance với một [Nuxt plugin](/docs/guide/directory-structure/plugins).

::note
`$fetch` là một configured instance của [ofetch](https://github.com/unjs/ofetch) which supports adding base URL của Nuxt server của bạn cũng như direct function calls during SSR (avoiding HTTP roundtrips).
::

Hãy pretend here rằng:
- Main API là https://api.nuxt.com
- Chúng ta are storing JWT token trong một session với [nuxt-auth-utils](https://github.com/atinux/nuxt-auth-utils)
- Nếu API responds với một `401` status code, chúng ta redirect user đến `/login` page

```ts [plugins/api.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const { session } = useUserSession()

  const api = $fetch.create({
    baseURL: 'https://api.nuxt.com',
    onRequest({ request, options, error }) {
      if (session.value?.token) {
        // note that this relies on ofetch >= 1.4.0 - you may need to refresh your lockfile
        options.headers.set('Authorization', `Bearer ${session.value?.token}`)
      }
    },
    async onResponseError({ response }) {
      if (response.status === 401) {
        await nuxtApp.runWithContext(() => navigateTo('/login'))
      }
    }
  })

  // Expose to useNuxtApp().$api
  return {
    provide: {
      api
    }
  }
})
```

Với Nuxt plugin này, `$api` is exposed từ `useNuxtApp()` để make API calls directly từ Vue components:

```vue [app.vue]
<script setup>
const { $api } = useNuxtApp()
const { data: modules } = await useAsyncData('modules', () => $api('/modules'))
</script>
```

::callout
Wrapping với [`useAsyncData`](/docs/api/composables/use-async-data) **avoid double data fetching khi doing server-side rendering** (server & client on hydration).
::

## Custom `useFetch`/`useAsyncData`

Bây giờ rằng `$api` has logic chúng ta want, hãy create một `useAPI` composable để replace usage của `useAsyncData` + `$api`:

```ts [composables/useAPI.ts]
import type { UseFetchOptions } from 'nuxt/app'

export function useAPI<T>(
  url: string | (() => string),
  options?: UseFetchOptions<T>,
) {
  return useFetch(url, {
    ...options,
    $fetch: useNuxtApp().$api as typeof $fetch
  })
}
```

Hãy use new composable và have một nice và clean component:

```vue [app.vue]
<script setup>
const { data: modules } = await useAPI('/modules')
</script>
```

Nếu bạn want để customize type của bất kỳ error nào returned, bạn cũng có thể do so:

```ts
import type { FetchError } from 'ofetch'
import type { UseFetchOptions } from 'nuxt/app'

interface CustomError {
  message: string
  statusCode: number
}

export function useAPI<T>(
  url: string | (() => string),
  options?: UseFetchOptions<T>,
) {
  return useFetch<T, FetchError<CustomError>>(url, {
    ...options,
    $fetch: useNuxtApp().$api
  })
}
```

::note
Example này demonstrates how để use một custom `useFetch`, nhưng same structure is identical cho một custom `useAsyncData`.
::

:link-example{to="/docs/examples/advanced/use-custom-fetch-composable"}

:video-accordion{title="Watch a video about custom $fetch and Repository Pattern in Nuxt" videoId="jXH8Tr-exhI"}

::note
Chúng ta are currently discussing để find một cleaner way để let bạn create một custom fetcher, see https://github.com/nuxt/nuxt/issues/14736.
::
