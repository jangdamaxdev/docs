---
title: "Module Author Guide"
description: "Learn how to create a Nuxt Module to integrate, enhance or extend any Nuxt applications."
image: '/socials/module-author-guide.jpg'
---

Nuxt's [configuration](/docs/api/nuxt-config) và [hooks](/docs/guide/going-further/hooks) systems make it possible to customize every aspect of Nuxt và add any integration you might need (Vue plugins, CMS, server routes, components, logging, etc.).

**Nuxt Modules** là functions sequentially run khi starting Nuxt trong development mode bằng `nuxt dev` hoặc building một project cho production với `nuxt build`.
Với modules, bạn có thể encapsulate, properly test, và share custom solutions như npm packages mà không add unnecessary boilerplate vào project của bạn, hoặc requiring changes vào Nuxt itself.

## Quick Start

Chúng tôi recommend bạn get started với Nuxt Modules bằng [starter template](https://github.com/nuxt/starter/tree/module) của chúng tôi:

::code-group{sync="pm"}

```bash [npm]
npm create nuxt -- -t module my-module
```

```bash [yarn]
yarn create nuxt -t module my-module
```

```bash [pnpm]
pnpm create nuxt -t module my-module
```

```bash [bun]
bun create nuxt -t module my-module
```

::

Điều này sẽ create một `my-module` project với tất cả boilerplate necessary để develop và publish module của bạn.

**Next steps:**

1. Open `my-module` trong IDE của bạn
2. Install dependencies bằng favorite package manager của bạn
3. Prepare local files cho development bằng `npm run dev:prepare`
4. Follow document này để learn more về Nuxt Modules

### Using the Starter

Learn cách perform basic tasks với module starter.

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/navigating-the-official-starter-template?friend=nuxt" target="_blank"}
Watch Vue School video về Nuxt module starter template.
::

#### How to Develop

Trong khi source code của module sống trong `src` directory, trong most cases, để develop một module, bạn need một Nuxt application. Đó là lý do `playground` directory exist. Nó là một Nuxt application bạn có thể tinker với mà already configured để run với module của bạn.

Bạn có thể interact với playground như với bất kỳ Nuxt application nào.

- Launch development server của nó với `npm run dev`, nó should reload itself khi bạn make changes vào module của bạn trong `src` directory
- Build nó với `npm run dev:build`

::note
Tất cả other `nuxt` commands có thể được used against `playground` directory (e.g. `nuxt <COMMAND> playground`). Feel free để declare additional `dev:*` scripts trong `package.json` của bạn referencing chúng cho convenience.
::

#### How to Test

Module starter comes với một basic test suite:

- A linter powered bởi [ESLint](https://eslint.org), run nó với `npm run lint`
- A test runner powered bởi [Vitest](https://vitest.dev), run nó với `npm run test` hoặc `npm run test:watch`

::tip
Feel free để augment default test strategy này để better suit needs của bạn.
::

#### How to Build

Nuxt Modules come với own builder provided bởi [`@nuxt/module-builder`](https://github.com/nuxt/module-builder#readme). Builder này doesn't require bất kỳ configuration nào trên end của bạn, supports TypeScript, và makes sure assets của bạn properly bundled để được distributed đến other Nuxt applications.

Bạn có thể build module của bạn bằng cách running `npm run prepack`.

::tip
Trong khi building module của bạn có thể useful trong một số cases, most of the time bạn won't need để build nó on your own: `playground` takes care của nó trong khi developing, và release script also has you covered khi publishing.
::

#### How to Publish

::important
Trước khi publishing module của bạn đến npm, makes sure bạn have [npmjs.com](https://www.npmjs.com) account và authenticated đến nó locally với `npm login`.
::

Trong khi bạn có thể publish module của bạn bằng bumping version của nó và using `npm publish` command, module starter comes với một release script helps bạn make sure bạn publish một working version của module đến npm và more.

Để use release script, first, commit tất cả changes của bạn (chúng tôi recommend bạn follow [Conventional Commits](https://www.conventionalcommits.org) để also take advantage của automatic version bump và changelog update), sau đó run release script với `npm run release`.

Khi running release script, following sẽ happen:

- First, nó sẽ run test suite của bạn bằng:
  - Running linter (`npm run lint`)
  - Running unit, integration, và e2e tests (`npm run test`)
  - Building module (`npm run prepack`)
- Sau đó, nếu test suite của bạn went well, nó sẽ proceed để publish module của bạn bằng:
  - Bumping module version của bạn và generating một changelog according đến Conventional Commits của bạn
  - Publishing module đến npm (cho purpose đó, module sẽ được built again để ensure updated version number của nó được taken into account trong published artifact)
  - Pushing một git tag representing newly published version đến git remote origin của bạn

::tip
As với other scripts, feel free để fine-tune default `release` script trong `package.json` của bạn để better suit needs của bạn.
::

## Developing Modules

Nuxt Modules come với một variety của powerful APIs và patterns allowing chúng để alter một Nuxt application trong pretty much any way possible. Section này teaches bạn how để take advantage của those.

### Module Anatomy

Chúng ta có thể consider hai kinds của Nuxt Modules:

- published modules được distributed trên npm - bạn có thể see một list của một số community modules trên [the Nuxt website](/modules).
- "local" modules, chúng exist within một Nuxt project itself, either [inlined in Nuxt config](/docs/api/nuxt-config#modules) hoặc as part của [the `modules` directory](/docs/guide/directory-structure/modules).

Trong either case, anatomy của chúng similar.

#### Module Definition

::note
Khi using starter, module definition của bạn available tại `src/module.ts`.
::

Module definition là entry point của module của bạn. Nó là what gets loaded bởi Nuxt khi module của bạn được referenced within một Nuxt configuration.

Tại low level, một Nuxt Module definition là một simple, potentially asynchronous, function accepting inline user options và một `nuxt` object để interact với Nuxt.

```ts
export default function (inlineOptions, nuxt) {
  // You can do whatever you like here..
  console.log(inlineOptions.token) // `123`
  console.log(nuxt.options.dev) // `true` or `false`
  nuxt.hook('ready', async nuxt => {
    console.log('Nuxt is ready')
  })
}
```

Bạn có thể get type-hint support cho function này bằng higher-level `defineNuxtModule` helper provided bởi [Nuxt Kit](/docs/guide/going-further/kit).

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule((options, nuxt) => {
  nuxt.hook('pages:extend', pages => {
    console.log(`Discovered ${pages.length} pages`)
  })
})
```

Tuy nhiên, **chúng tôi do not recommend** using low-level function definition này. Thay vào đó, để define một module, **chúng tôi recommend** using object-syntax với `meta` property để identify module của bạn, especially khi publishing đến npm.

Helper này makes writing Nuxt modules more straightforward bằng implementing many common patterns needed bởi modules, guaranteeing future compatibility và improving experience cho both module authors và users.

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    // Usually the npm package name of your module
    name: '@nuxtjs/example',
    // The key in `nuxt.config` that holds your module options
    configKey: 'sample',
    // Compatibility constraints
    compatibility: {
      // Semver version of supported nuxt versions
      nuxt: '>=3.0.0'
    }
  },
  // Default configuration options for your module, can also be a function returning those
  defaults: {},
  // Shorthand sugar to register Nuxt hooks
  hooks: {},
  // The function holding your module logic, it can be asynchronous
  setup(moduleOptions, nuxt) {
    // ...
  }
})
```

Ultimately `defineNuxtModule` returns một wrapper function với lower level `(inlineOptions, nuxt)` module signature. Wrapper function này applies defaults và other necessary steps trước calling `setup` function của bạn:

- Support `defaults` và `meta.configKey` cho automatically merging module options
- Type hints và automated type inference
- Add shims cho basic Nuxt 2 compatibility
- Ensure module gets installed only once using một unique key computed từ `meta.name` hoặc `meta.configKey`
- Automatically register Nuxt hooks
- Automatically check cho compatibility issues based trên module meta
- Expose `getOptions` và `getMeta` cho internal usage của Nuxt
- Ensuring backward và upward compatibility as long as module using `defineNuxtModule` từ latest version của `@nuxt/kit`
- Integration với module builder tooling

#### Runtime Directory

::note
Khi using starter, runtime directory available tại `src/runtime`.
::

Modules, như everything trong một Nuxt configuration, aren't included trong application runtime của bạn. Tuy nhiên, bạn might want module của bạn để provide, hoặc inject runtime code vào application it's installed on. Đó là what runtime directory enables bạn để do.

Inside runtime directory, bạn có thể provide bất kỳ kind nào của assets related đến Nuxt App:
- Vue components
- Composables
- [Nuxt plugins](/docs/guide/directory-structure/plugins)

Đến [server engine](/docs/guide/concepts/server-engine), Nitro:
- API routes
- Middlewares
- Nitro plugins

Hoặc bất kỳ kind nào khác của asset bạn want để inject trong users' Nuxt applications:
- Stylesheets
- 3D models
- Images
- etc.

Bạn sẽ then be able để inject tất cả those assets inside application từ [module definition](#module-definition) của bạn.

::tip
Learn more về asset injection trong [the recipes section](#recipes).
::

::warning
Published modules cannot leverage auto-imports cho assets within runtime directory của chúng. Thay vào đó, chúng have để import chúng explicitly từ `#imports` hoặc alike.

Indeed, auto-imports aren't enabled cho files within `node_modules` (location where một published module sẽ eventually live) cho performance reasons.
::

### Tooling

Modules come với một set của first-party tools để help bạn với development của chúng.

#### `@nuxt/module-builder`

[Nuxt Module Builder](https://github.com/nuxt/module-builder#readme) là một zero-configuration build tool taking care của tất cả heavy lifting để build và ship module của bạn. Nó ensures proper compatibility của module build artifact của bạn với Nuxt applications.

#### `@nuxt/kit`

[Nuxt Kit](/docs/guide/going-further/kit) provides composable utilities để help module của bạn interact với Nuxt applications. Nó recommended để use Nuxt Kit utilities over manual alternatives whenever possible để ensure better compatibility và code readability của module của bạn.

:read-more{to="/docs/guide/going-further/kit"}

#### `@nuxt/test-utils`

[Nuxt Test Utils](/docs/getting-started/testing) là một collection của utilities để help set up và run Nuxt applications within module tests của bạn.

### Recipes

Find here common patterns used để author modules.

#### Altering Nuxt Configuration

Nuxt configuration có thể được read và altered bởi modules. Here's một example của một module enabling một experimental feature.

```js
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // We create the `experimental` object if it doesn't exist yet
    nuxt.options.experimental ||= {}
    nuxt.options.experimental.componentIslands = true
  }
})
```

Khi bạn need để handle more complex configuration alterations, bạn should consider using [defu](https://github.com/unjs/defu).

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/extending-and-altering-nuxt-configuration-and-options?friend=nuxt" target="_blank"}
Watch Vue School video về altering Nuxt configuration.
::

#### Exposing Options to Runtime

Vì modules aren't part của application runtime, options của chúng aren't either. Tuy nhiên, trong many cases, bạn might need access đến một số của those module options within runtime code của bạn. Chúng tôi recommend exposing needed config bằng Nuxt's [`runtimeConfig`](/docs/api/nuxt-config#runtimeconfig).

<!-- TODO: Update after #18466 (or equivalent) -->

```js
import { defineNuxtModule } from '@nuxt/kit'
import { defu } from 'defu'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.options.runtimeConfig.public.myModule = defu(nuxt.options.runtimeConfig.public.myModule, {
      foo: options.foo
    })
  }
})
```

Note rằng chúng tôi use [`defu`](https://github.com/unjs/unenv) để extend public runtime configuration user provides thay vì overwriting nó.

Bạn có thể then access module options của bạn trong một plugin, component, application như bất kỳ runtime configuration nào khác:

```js
const options = useRuntimeConfig().public.myModule
```

::warning
Be careful không để expose bất kỳ sensitive module configuration nào trên public runtime config, như private API keys, vì chúng sẽ end up trong public bundle.
::

:read-more{to="/docs/guide/going-further/runtime-config"}

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/passing-and-exposing-module-options?friend=nuxt" target="_blank"}
Watch Vue School video về passing và exposing Nuxt module options.
::

#### Injecting Plugins With `addPlugin`

Plugins là một common way cho một module để add runtime logic. Bạn có thể use `addPlugin` utility để register chúng từ module của bạn.

```js
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // Create resolver to resolve relative paths
    const resolver = createResolver(import.meta.url)

    addPlugin(resolver.resolve('./runtime/plugin'))
  }
})
```

:read-more{to="/docs/guide/going-further/kit"}

#### Injecting Vue Components With `addComponent`

Nếu module của bạn should provide Vue components, bạn có thể use `addComponent` utility để add chúng như auto-imports cho Nuxt để resolve.

```js
import { defineNuxtModule, addComponent } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    // From the runtime directory
    addComponent({
      name: 'MySuperComponent', // name of the component to be used in vue templates
      export: 'MySuperComponent', // (optional) if the component is a named (rather than default) export
      filePath: resolver.resolve('runtime/components/MySuperComponent.vue')
    })

    // From a library
    addComponent({
      name: 'MyAwesomeComponent', // name of the component to be used in vue templates
      export: 'MyAwesomeComponent', // (optional) if the component is a named (rather than default) export
      filePath: '@vue/awesome-components'
    })
  }
})
```

Alternatively, bạn có thể add một entire directory bằng using `addComponentsDir`.

```ts
import { defineNuxtModule, addComponentsDir } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addComponentsDir({
      path: resolver.resolve('runtime/components')
    })
  }
})
```

#### Injecting Composables With `addImports` and `addImportsDir`

Nếu module của bạn should provide composables, bạn có thể use `addImports` utility để add chúng như auto-imports cho Nuxt để resolve.

```ts
import { defineNuxtModule, addImports, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addImports({
      name: 'useComposable', // name of the composable to be used
      as: 'useComposable',
      from: resolver.resolve('runtime/composables/useComposable') // path of composable
    })
  }
})
```

Alternatively, bạn có thể add một entire directory bằng using `addImportsDir`.

```ts
import { defineNuxtModule, addImportsDir, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addImportsDir(resolver.resolve('runtime/composables'))
  }
})
```

#### Injecting Server Routes With `addServerHandler`

```ts
import { defineNuxtModule, addServerHandler, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addServerHandler({
      route: '/api/hello',
      handler: resolver.resolve('./runtime/server/api/hello/index.get')
    })
  }
})
```

Bạn cũng có thể add một dynamic server route:

```ts
import { defineNuxtModule, addServerHandler, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addServerHandler({
      route: '/api/hello/:name',
      handler: resolver.resolve('./runtime/server/api/hello/[name].get')
    })
  }
})
```

#### Injecting Other Assets

Nếu module của bạn should provide other kinds của assets, chúng cũng có thể được injected. Here's một simple example module injecting một stylesheet thông qua Nuxt's `css` array.

```js
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.options.css.push(resolver.resolve('./runtime/style.css'))
  }
})
```

Và một more advanced one, exposing một folder của assets thông qua [Nitro](/docs/guide/concepts/server-engine)'s `publicAssets` option:

```js
import { defineNuxtModule, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.hook('nitro:config', async (nitroConfig) => {
      nitroConfig.publicAssets ||= []
      nitroConfig.publicAssets.push({
        dir: resolver.resolve('./runtime/public'),
        maxAge: 60 * 60 * 24 * 365 // 1 year
      })
    })
  }
})
```

#### Using Other Modules in Your Module

Nếu module của bạn depends trên other modules, bạn có thể add chúng bằng using Nuxt Kit's `installModule` utility. Ví dụ, nếu bạn wanted để use Nuxt Tailwind trong module của bạn, bạn có thể add nó như below:

```ts
import { defineNuxtModule, createResolver, installModule } from '@nuxt/kit'

export default defineNuxtModule<ModuleOptions>({
  async setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    // We can inject our CSS file which includes Tailwind's directives
    nuxt.options.css.push(resolver.resolve('./runtime/assets/styles.css'))

    await installModule('@nuxtjs/tailwindcss', {
      // module configuration
      exposeConfig: true,
      config: {
        darkMode: 'class',
        content: {
          files: [
            resolver.resolve('./runtime/components/**/*.{vue,mjs,ts}'),
            resolver.resolve('./runtime/*.{mjs,js,ts}')
          ]
        }
      }
    })
  }
})
```

#### Using Hooks

[Lifecycle hooks](/docs/guide/going-further/hooks) allow bạn để expand almost every aspect của Nuxt. Modules có thể hook đến chúng programmatically hoặc thông qua `hooks` map trong definition của chúng.

```js
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  // Hook to the `app:error` hook through the `hooks` map
  hooks: {
    'app:error': (err) => {
      console.info(`This error happened: ${err}`);
    }
  },
  setup (options, nuxt) {
    // Programmatically hook to the `pages:extend` hook
    nuxt.hook('pages:extend', (pages) => {
      console.info(`Discovered ${pages.length} pages`);
    })
  }
})
```

:read-more{to="/docs/api/advanced/hooks"}

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/nuxt-lifecycle-hooks?friend=nuxt" target="_blank"}
Watch Vue School video về using Nuxt lifecycle hooks trong modules.
::

::note
**Module cleanup**
:br
:br
Nếu module của bạn opens, handles, hoặc starts một watcher, bạn should close nó khi Nuxt lifecycle done. `close` hook available cho this.

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.hook('close', async nuxt => {
      // Your custom code here
    })
  }
})
```
::

##### Custom Hooks

Modules cũng có thể define và call custom hooks của chúng, là một powerful pattern để make module của bạn extensible.

Nếu bạn expect other modules để be able để subscribe đến module's hooks của bạn, bạn should call chúng trong `modules:done` hook. Điều này ensures rằng tất cả other modules have had một chance để be set up và register listeners của chúng đến hook của bạn trong `setup` function của chúng.

```ts
// my-module/module.ts
import { defineNuxtModule } from '@nuxt/kit'

export interface ModuleHooks {
  'my-module:custom-hook': (payload: { foo: string }) => void
}

export default defineNuxtModule({
  setup (options, nuxt) {
    // Call your hook in `modules:done`
    nuxt.hook('modules:done', async () => {
      const payload = { foo: 'bar' }
      await nuxt.callHook('my-module:custom-hook', payload)
    })
  }
})
```

#### Adding Templates/Virtual Files

Nếu bạn need để add một virtual file có thể được imported vào user's app, bạn có thể use `addTemplate` utility.

```ts
import { defineNuxtModule, addTemplate } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // The file is added to Nuxt's internal virtual file system and can be imported from '#build/my-module-feature.mjs'
    addTemplate({
      filename: 'my-module-feature.mjs',
      getContents: () => 'export const myModuleFeature = () => "hello world !"'
    })
  }
})
```

Cho server, bạn should use `addServerTemplate` utility thay thế.

```ts
import { defineNuxtModule, addServerTemplate } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // The file is added to Nitro's virtual file system and can be imported in the server code from 'my-server-module.mjs'
    addServerTemplate({
      filename: 'my-server-module.mjs',
      getContents: () => 'export const myServerModule = () => "hello world !"'
    })
  }
})
```

#### Adding Type Declarations

Bạn might also want để add một type declaration đến user's project (ví dụ, để augment một Nuxt interface
hoặc provide một global type của your own). Cho this, Nuxt provides `addTypeTemplate` utility that both
writes một template đến disk và adds một reference đến nó trong generated `nuxt.d.ts` file.

Nếu module của bạn should augment types handled bởi Nuxt, bạn có thể use `addTypeTemplate` để perform operation này:

```js
import { defineNuxtModule, addTemplate, addTypeTemplate } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    addTypeTemplate({
      filename: 'types/my-module.d.ts',
      getContents: () => `// Generated by my-module
        interface MyModuleNitroRules {
          myModule?: { foo: 'bar' }
        }
        declare module 'nitropack/types' {
          interface NitroRouteRules extends MyModuleNitroRules {}
          interface NitroRouteConfig extends MyModuleNitroRules {}
        }
        export {}`
    })
  }
})
```

Nếu bạn need more granular control, bạn có thể use `prepare:types` hook để register một callback sẽ inject types của bạn.

```ts
const template = addTemplate({ /* template options */ })
nuxt.hook('prepare:types', ({ references }) => {
  references.push({ path: template.dst })
})
```

##### Updating Templates

Nếu bạn need để update templates/virtual files của bạn, bạn có thể leverage `updateTemplates` utility như this :

```ts
nuxt.hook('builder:watch', async (event, path) => {
  if (path.includes('my-module-feature.config')) {
    // This will reload the template that you registered
    updateTemplates({ filter: t => t.filename === 'my-module-feature.mjs' })
  }
})
```

### Testing

Testing helps ensuring module của bạn works như expected given various setup. Find trong section này how để perform various kinds của tests against module của bạn.

#### Unit and Integration

::tip
Chúng tôi still discussing và exploring how để ease unit và integration testing trên Nuxt Modules.
:br :br
[Check out this RFC để join conversation](https://github.com/nuxt/nuxt/discussions/18399).
::

#### End to End

[Nuxt Test Utils](/docs/getting-started/testing) là go-to library để help bạn test module của bạn trong một end-to-end way. Here's workflow để adopt với nó:

1. Create một Nuxt application để be used như một "fixture" inside `test/fixtures/*`
2. Setup Nuxt với fixture này inside test file của bạn
3. Interact với fixture bằng utilities từ `@nuxt/test-utils` (e.g. fetching một page)
4. Perform checks related đến fixture này (e.g. "HTML contains ...")
5. Repeat

Trong practice, fixture:

```js [test/fixtures/ssr/nuxt.config.ts]
// 1. Create a Nuxt application to be used as a "fixture"
import MyModule from '../../../src/module'

export default defineNuxtConfig({
  ssr: true,
  modules: [
    MyModule
  ]
})
```

Và test của nó:

```js [test/rendering.ts]
import { describe, it, expect } from 'vitest'
import { fileURLToPath } from 'node:url'
import { setup, $fetch } from '@nuxt/test-utils/e2e'

describe('ssr', async () => {
  // 2. Setup Nuxt with this fixture inside your test file
  await setup({
    rootDir: fileURLToPath(new URL('./fixtures/ssr', import.meta.url)),
  })

  it('renders the index page', async () => {
    // 3. Interact with the fixture using utilities from `@nuxt/test-utils`
    const html = await $fetch('/')

    // 4. Perform checks related to this fixture
    expect(html).toContain('<div>ssr</div>')
  })
})

// 5. Repeat
describe('csr', async () => { /* ... */ })
```

::tip
Một example của workflow như this available trên [the module starter](https://github.com/nuxt/starter/blob/module/test/basic.test.ts).
::

#### Manual QA With Playground and Externally

Having một playground Nuxt application để test module của bạn khi developing nó là really useful. [The module starter integrates một cho purpose đó](#how-to-develop).

Bạn có thể test module của bạn với other Nuxt applications (applications that aren't part của module repository của bạn) locally. Để do so, bạn có thể use [`npm pack`](https://docs.npmjs.com/cli/commands/npm-pack) command, hoặc package manager equivalent của bạn, để create một tarball từ module của bạn. Sau đó trong test project của bạn, bạn có thể add module của bạn đến `package.json` packages như: `"my-module": "file:/path/to/tarball.tgz"`.

Sau that, bạn should be able để reference `my-module` như trong bất kỳ regular project nào.

### Best Practices

Với great power comes great responsibility. Trong khi modules powerful, here are một số best practices để keep trong mind trong khi authoring modules để keep applications performant và developer experience great.

#### Async Modules

As we've seen, Nuxt Modules có thể asynchronous. Ví dụ, bạn may want để develop một module needs fetching một số API hoặc calling một async function.

Tuy nhiên, be careful với asynchronous behaviors vì Nuxt sẽ wait cho module của bạn để setup trước going đến next module và starting development server, build process, etc. Prefer deferring time-consuming logic đến Nuxt hooks.

::warning
Nếu module của bạn takes more than **1 second** để setup, Nuxt sẽ emit một warning về nó.
::

#### Always Prefix Exposed Interfaces

Nuxt Modules should provide một explicit prefix cho bất kỳ exposed configuration, plugin, API, composable, hoặc component để avoid conflict với other modules và internals.

Ideally, bạn should prefix chúng với module's name của bạn (e.g. if module của bạn called `nuxt-foo`, expose `<FooButton>` và `useFooBar()` và **not** `<Button>` và `useBar()`).

#### Be TypeScript Friendly

Nuxt has first-class TypeScript integration cho best developer experience.

Exposing types và using TypeScript để develop modules benefits users even when not using TypeScript directly.

#### Avoid CommonJS Syntax

Nuxt relies trên native ESM. Please read [Native ES Modules](/docs/guide/concepts/esm) cho more information.

#### Document Module Usage

Consider documenting module usage trong readme file:

- Why use module này?
- How để use module này?
- What does module này do?

Linking đến integration website và documentation always một good idea.

#### Provide a StackBlitz Demo or Boilerplate

It's một good practice để make một minimal reproduction với module của bạn và [StackBlitz](https://nuxt.new/s/v4) mà bạn add đến module readme của bạn.

Điều này not only provides potential users của module của bạn một quick và easy way để experiment với module nhưng also một easy way cho chúng để build minimal reproductions chúng có thể send bạn khi chúng encounter issues.

#### Do Not Advertise With a Specific Nuxt Version

Nuxt, Nuxt Kit, và other new toolings made để have both forward và backward compatibility trong mind.

Please use "X for Nuxt" thay vì "X for Nuxt 3" để avoid fragmentation trong ecosystem và prefer using `meta.compatibility` để set Nuxt version constraints.

#### Stick With Starter Defaults

Module starter comes với một default set của tools và configurations (e.g. ESLint configuration). Nếu bạn plan trên open-sourcing module của bạn, sticking với those defaults ensures module của bạn shares một consistent coding style với other [community modules](/modules) out there, making nó easier cho others để contribute.

## Ecosystem

[Nuxt Module ecosystem](/modules) represents more than 15 million monthly NPM downloads và provides extended functionalities và integrations với all sort của tools. Bạn có thể be part của ecosystem này!

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/exploring-nuxt-modules-ecosystem-and-module-types?friend=nuxt" target="_blank"}
Watch Vue School video về Nuxt module types.
::

### Module Types

**Official modules** là modules prefixed (scoped) với `@nuxt/` (e.g. [`@nuxt/content`](https://content.nuxtjs.org)). Chúng made và maintained actively bởi Nuxt team. Like với framework, contributions từ community more than welcome để help make chúng better!

**Community modules** là modules prefixed (scoped) với `@nuxtjs/` (e.g. [`@nuxtjs/tailwindcss`](https://tailwindcss.nuxtjs.org)). Chúng proven modules made và maintained bởi community members. Again, contributions welcome từ anyone.

**Third-party và other community modules** là modules (often) prefixed với `nuxt-`. Anyone có thể make chúng, using prefix này allows những modules này để be discoverable trên npm. Đây là best starting point để draft và try một idea!

**Private hoặc personal modules** là modules made cho own use case hoặc company của bạn. Chúng don't need để follow bất kỳ naming rules nào để work với Nuxt và often seen scoped under một npm organization (e.g. `@my-company/nuxt-auth`)

### Listing Your Community Module

Bất kỳ community modules nào welcome để be listed trên [the module list](/modules). Để be listed, [open một issue trong nuxt/modules](https://github.com/nuxt/modules/issues/new?template=module_request.yml) repository. Nuxt team có thể help bạn để apply best practices trước listing.

### Joining `nuxt-modules` and `@nuxtjs/`

Bằng moving modules của bạn đến [nuxt-modules](https://github.com/nuxt-modules), always someone else để help, và this way, chúng ta có thể join forces để make một perfect solution.

Nếu bạn have một already published và working module, và want để transfer nó đến `nuxt-modules`, [open một issue trong nuxt/modules](https://github.com/nuxt/modules/issues/new).

Bằng joining `nuxt-modules` chúng ta có thể rename community module của bạn under `@nuxtjs/` scope và provide một subdomain (e.g. `my-module.nuxtjs.org`) cho documentation của nó.

<!-- ## Module Internals

Maybe just a quick section touching on "how modules work" under the hood, priority, etc. -->
