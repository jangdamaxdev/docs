---
title: 'ES Modules'
description: "Nuxt uses native ES modules."
---

Hướng dẫn này giúp giải thích về ES Modules và cách làm cho ứng dụng Nuxt (hoặc thư viện upstream) tương thích với ESM.

## Background

### CommonJS Modules

CommonJS (CJS) là định dạng được giới thiệu bởi Node.js, cho phép chia sẻ chức năng giữa các mô-đun JavaScript độc lập ([read more](https://nodejs.org/api/modules.html)).
Bạn có thể đã quen thuộc với cú pháp này:

```js
const a = require('./a')

module.exports.a = a
```

Các trình đóng gói (bundlers) như webpack và Rollup hỗ trợ cú pháp này và cho phép bạn sử dụng các mô-đun được viết bằng CommonJS trong trình duyệt.

### ESM Syntax

Hầu hết thời gian, khi mọi người nói về ESM so với CJS, họ đang đề cập đến một cú pháp khác để viết [modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules).

```js
import a from './a'

export { a }
```

Trước khi ECMAScript Modules (ESM) trở thành tiêu chuẩn (mất hơn 10 năm!), các công cụ như [webpack](https://webpack.js.org/guides/ecma-script-modules) và thậm chí các ngôn ngữ như TypeScript đã bắt đầu hỗ trợ **ESM syntax**.
Tuy nhiên, có một số khác biệt quan trọng với đặc tả thực tế; đây là [một giải thích hữu ích](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive).

### What is 'Native' ESM?

Bạn có thể đã viết ứng dụng của mình bằng ESM syntax từ lâu. Sau tất cả, nó được hỗ trợ gốc bởi trình duyệt, và trong Nuxt 2 chúng tôi đã biên dịch tất cả mã bạn viết sang định dạng phù hợp (CJS cho server, ESM cho browser).

Khi thêm các module vào package, mọi thứ hơi khác một chút. Một thư viện mẫu có thể xuất cả phiên bản CJS và ESM, và cho phép chúng ta chọn phiên bản muốn sử dụng:

```json
{
  "name": "sample-library",
  "main": "dist/sample-library.cjs.js",
  "module": "dist/sample-library.esm.js"
}
```

Vì vậy trong Nuxt 2, trình đóng gói (webpack) sẽ lấy tệp CJS ('main') cho bản build server và sử dụng tệp ESM ('module') cho bản build client.

Tuy nhiên, trong các phiên bản LTS gần đây của Node.js, giờ đây có thể [sử dụng native ESM module](https://nodejs.org/api/esm.html) bên trong Node.js. Điều này có nghĩa là Node.js tự xử lý JavaScript bằng ESM syntax, mặc dù nó không làm điều này theo mặc định. Hai cách phổ biến nhất để kích hoạt ESM syntax là:

- đặt `"type": "module"` trong `package.json` và tiếp tục sử dụng phần mở rộng `.js`
- sử dụng phần mở rộng tệp `.mjs` (được khuyến nghị)

Đây là những gì chúng tôi làm cho Nuxt Nitro; chúng tôi xuất tệp `.output/server/index.mjs`. Điều này báo cho Node.js biết xử lý tệp này như một native ES module.

### What Are Valid Imports in a Node.js Context?

Khi bạn `import` một module thay vì `require` nó, Node.js phân giải nó khác đi. Ví dụ, khi bạn import `sample-library`, Node.js sẽ tìm không phải `main` mà là mục `exports` hoặc `module` trong `package.json` của thư viện đó.

Điều này cũng đúng với dynamic imports, như `const b = await import('sample-library')`.

Node hỗ trợ các loại import sau (xem [docs](https://nodejs.org/api/packages.html#determining-module-system)):

1. tệp kết thúc bằng `.mjs` - những tệp này được kỳ vọng sử dụng ESM syntax
1. tệp kết thúc bằng `.cjs` - những tệp này được kỳ vọng sử dụng CJS syntax
1. tệp kết thúc bằng `.js` - những tệp này được kỳ vọng sử dụng CJS syntax trừ khi `package.json` có `"type": "module"`

### What Kinds of Problems Can There Be?

Trong một thời gian dài, các tác giả module đã sản xuất các bản build ESM syntax nhưng sử dụng quy ước như `.esm.js` hoặc `.es.js`, mà họ đã thêm vào trường `module` trong `package.json`. Điều này không thành vấn đề cho đến nay vì chúng chỉ được sử dụng bởi các trình đóng gói như webpack, không đặc biệt quan tâm đến phần mở rộng tệp.

Tuy nhiên, nếu bạn cố import một package có tệp `.esm.js` trong ngữ cảnh Node.js ESM, nó sẽ không hoạt động, và bạn sẽ nhận được lỗi như:

```bash [Terminal]
(node:22145) Warning: To load an ES module, set "type": "module" in the package.json or use the .mjs extension.
/path/to/index.js:1

export default {}
^^^^^^

SyntaxError: Unexpected token 'export'
    at wrapSafe (internal/modules/cjs/loader.js:1001:16)
    at Module._compile (internal/modules/cjs/loader.js:1049:27)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10)
    ....
    at async Object.loadESM (internal/process/esm_loader.js:68:5)
```

Bạn cũng có thể nhận được lỗi này nếu bạn có named import từ bản build ESM syntax mà Node.js nghĩ là CJS:

```bash [Terminal]
file:///path/to/index.mjs:5
import { named } from 'sample-library'
         ^^^^^
SyntaxError: Named export 'named' not found. The requested module 'sample-library' is a CommonJS module, which may not support all module.exports as named exports.

CommonJS modules can always be imported via the default export, for example using:

import pkg from 'sample-library';
const { named } = pkg;

    at ModuleJob._instantiate (internal/modules/esm/module_job.js:120:21)
    at async ModuleJob.run (internal/modules/esm/module_job.js:165:5)
    at async Loader.import (internal/modules/esm/loader.js:177:24)
    at async Object.loadESM (internal/process/esm_loader.js:68:5)
```

## Troubleshooting ESM Issues

Nếu bạn gặp các lỗi này, vấn đề gần như chắc chắn nằm ở thư viện upstream. Họ cần [sửa thư viện của họ](#library-author-guide) để hỗ trợ được import bởi Node.

### Transpiling Libraries

Trong lúc chờ đợi, bạn có thể bảo Nuxt không cố import các thư viện này bằng cách thêm chúng vào `build.transpile`:

```ts twoslash
export default defineNuxtConfig({
  build: {
    transpile: ['sample-library']
  }
})
```

Bạn có thể thấy rằng bạn _cũng_ cần thêm các package khác đang được import bởi các thư viện này.

### Aliasing Libraries

Trong một số trường hợp, bạn cũng có thể cần alias thủ công thư viện sang phiên bản CJS, ví dụ:

```ts twoslash
export default defineNuxtConfig({
  alias: {
    'sample-library': 'sample-library/dist/sample-library.cjs.js'
  }
})
```

### Default Exports

Một dependency với định dạng CommonJS, có thể sử dụng `module.exports` hoặc `exports` để cung cấp default export:

```js [node_modules/cjs-pkg/index.js]
module.exports = { test: 123 }
// or
exports.test = 123
```

Điều này thường hoạt động tốt nếu chúng ta `require` dependency đó:

```js [test.cjs]
const pkg = require('cjs-pkg')

console.log(pkg) // { test: 123 }
```

[Node.js trong chế độ native ESM](https://nodejs.org/api/esm.html#interoperability-with-commonjs), [typescript với `esModuleInterop` được bật](https://www.typescriptlang.org/tsconfig#esModuleInterop) và các trình đóng gói như webpack, cung cấp cơ chế tương thích để chúng ta có thể default import thư viện đó.
Cơ chế này thường được gọi là "interop require default":

```js
import pkg from 'cjs-pkg'

console.log(pkg) // { test: 123 }
```

Tuy nhiên, do sự phức tạp của việc phát hiện cú pháp và các định dạng bundle khác nhau, luôn có khả năng cơ chế interop default thất bại và chúng ta kết thúc với điều này:

```js
import pkg from 'cjs-pkg'

console.log(pkg) // { default: { test: 123 } }
```

Cũng khi sử dụng dynamic import syntax (trong cả tệp CJS và ESM), chúng ta luôn gặp tình huống này:

```js
import('cjs-pkg').then(console.log) // [Module: null prototype] { default: { test: '123' } }
```

Trong trường hợp này, chúng ta cần interop default export thủ công:

```js
// Static import
import { default as pkg } from 'cjs-pkg'

// Dynamic import
import('cjs-pkg').then(m => m.default || m).then(console.log)
```

Để xử lý các tình huống phức tạp hơn và an toàn hơn, chúng tôi khuyến nghị và sử dụng nội bộ [mlly](https://github.com/unjs/mlly) trong Nuxt có thể bảo tồn named exports.

```js
import { interopDefault } from 'mlly'

// Assuming the shape is { default: { foo: 'bar' }, baz: 'qux' }
import myModule from 'my-module'

console.log(interopDefault(myModule)) // { foo: 'bar', baz: 'qux' }
```

## Library Author Guide

Tin tốt là việc sửa các vấn đề tương thích ESM tương đối đơn giản. Có hai lựa chọn chính:

1. **Bạn có thể đổi tên các tệp ESM của bạn để kết thúc bằng `.mjs`.**

   _Đây là cách tiếp cận được khuyến nghị và đơn giản nhất._ Bạn có thể phải giải quyết các vấn đề với các dependency của thư viện và có thể với hệ thống build của bạn, nhưng trong hầu hết các trường hợp, điều này sẽ giải quyết vấn đề cho bạn. Cũng được khuyến nghị đổi tên các tệp CJS để kết thúc bằng `.cjs`, để rõ ràng nhất.

1. **Bạn có thể chọn làm cho toàn bộ thư viện của bạn chỉ hỗ trợ ESM**.

   Điều này có nghĩa là đặt `"type": "module"` trong `package.json` và đảm bảo rằng thư viện được build của bạn sử dụng ESM syntax. Tuy nhiên, bạn có thể gặp vấn đề với các dependency của mình - và cách tiếp cận này có nghĩa thư viện của bạn _chỉ_ có thể được tiêu thụ trong ngữ cảnh ESM.

### Migration

Bước đầu tiên từ CJS sang ESM là cập nhật bất kỳ việc sử dụng `require` nào để sử dụng `import` thay thế:

::code-group

```js [Before]
module.exports = ...

exports.hello = ...
```

```js [After]
export default ...

export const hello = ...
```

::

::code-group

```js [Before]
const myLib = require('my-lib')
```

```js [After]
import myLib from 'my-lib'
// or
const myLib = await import('my-lib').then(lib => lib.default || lib)
```

::

Trong ESM Modules, không giống CJS, các global `require`, `require.resolve`, `__filename` và `__dirname` không có sẵn
và nên được thay thế bằng `import()` và `import.meta.filename`.

::code-group

```js [Before]
import { join } from 'path'

const newDir = join(__dirname, 'new-dir')
```

```js [After]
import { fileURLToPath } from 'node:url'

const newDir = fileURLToPath(new URL('./new-dir', import.meta.url))
```

::

::code-group

```js [Before]
const someFile = require.resolve('./lib/foo.js')
```

```js [After]
import { resolvePath } from 'mlly'

const someFile = await resolvePath('my-lib', { url: import.meta.url })
```

::

### Best Practices

- Ưu tiên named exports thay vì default export. Điều này giúp giảm xung đột CJS. (xem phần [Default exports](#default-exports))

- Tránh phụ thuộc vào các built-in của Node.js và các dependency chỉ dành cho CommonJS hoặc Node.js nhiều nhất có thể để làm cho thư viện của bạn có thể sử dụng được trong Trình duyệt và Edge Workers mà không cần các polyfill của Nitro.

- Sử dụng trường `exports` mới với conditional exports. ([đọc thêm](https://nodejs.org/api/packages.html#conditional-exports)).

```json
{
  "exports": {
    ".": {
      "import": "./dist/mymodule.mjs"
    }
  }
}
```