---
title: 'Rendering Modes'
description: 'Learn about the different rendering modes available in Nuxt.'
---

Nuxt hỗ trợ các chế độ render khác nhau, [universal rendering](#universal-rendering), [client-side rendering](#client-side-rendering) nhưng cũng cung cấp [hybrid-rendering](#hybrid-rendering) và khả năng render ứng dụng của bạn trên [CDN Edge Servers](#edge-side-rendering).

Cả browser và server đều có thể hiểu mã JavaScript để biến đổi các component Vue.js thành các element HTML. Bước này được gọi là **rendering**. Nuxt hỗ trợ cả **universal** và **client-side** rendering. Hai phương pháp này đều có lợi ích và nhược điểm mà chúng tôi sẽ đề cập.

Theo mặc định, Nuxt sử dụng **universal rendering** để cung cấp trải nghiệm người dùng tốt hơn, hiệu suất và tối ưu hóa việc lập chỉ mục của công cụ tìm kiếm, nhưng bạn có thể chuyển đổi chế độ rendering trong [một dòng cấu hình](/docs/api/nuxt-config#ssr).

## Universal Rendering

Bước này tương tự như **server-side rendering** truyền thống được thực hiện bởi các ứng dụng PHP hoặc Ruby. Khi browser yêu cầu một URL với universal rendering được kích hoạt, Nuxt chạy mã JavaScript (Vue.js) trong môi trường server và trả về một trang HTML được render đầy đủ cho browser. Nuxt cũng có thể trả về một trang HTML được render đầy đủ từ cache nếu trang đã được tạo trước.

Người dùng ngay lập tức nhận được toàn bộ nội dung ban đầu của ứng dụng, ngược lại với client-side rendering.

Khi tài liệu HTML đã được tải xuống, browser diễn giải điều này và Vue.js tiếp quản tài liệu. Cùng một mã JavaScript đã từng chạy trên server bây giờ chạy trên client (browser) **lại** ở chế độ nền để kích hoạt tính tương tác (do đó **Universal rendering**) bằng cách gắn các listener của nó vào HTML. Điều này được gọi là **Hydration**. Khi hydration hoàn tất, trang có thể tận hưởng các lợi ích như giao diện động và chuyển tiếp trang.

Universal rendering cho phép ứng dụng Nuxt cung cấp thời gian tải trang nhanh trong khi vẫn giữ được lợi ích của client-side rendering. Hơn nữa, vì nội dung đã có sẵn trong tài liệu HTML, các crawler có thể lập chỉ mục mà không cần overhead.

![Users can access the static content when the HTML document is loaded. Hydration then allows page's interactivity](/assets/docs/concepts/rendering/ssr.svg)

**Cái gì được server-rendered và cái gì được client-rendered?**

Thật bình thường khi hỏi những phần nào của file Vue chạy trên server và/hoặc client trong chế độ universal rendering.

```vue [app.vue]
<script setup lang="ts">
const counter = ref(0); // thực thi trong môi trường server và client

const handleClick = () => {
  counter.value++; // chỉ thực thi trong môi trường client
};
</script>

<template>
  <div>
    <p>Count: {{ counter }}</p>
    <button @click="handleClick">Increment</button>
  </div>
</template>
```

Trong yêu cầu ban đầu, `counter` ref được khởi tạo trong server vì nó được render bên trong thẻ `<p>`. Nội dung của `handleClick` không bao giờ được thực thi ở đây. Trong quá trình hydration trong browser, `counter` ref được khởi tạo lại. `handleClick` cuối cùng gắn chính nó vào button; Do đó, hợp lý khi suy luận rằng nội dung của `handleClick` sẽ luôn chạy trong môi trường browser.

[Middlewares](/docs/guide/directory-structure/middleware) và [pages](/docs/guide/directory-structure/pages) chạy trong server và trên client trong quá trình hydration. [Plugins](/docs/guide/directory-structure/plugins) có thể được render trên server hoặc client hoặc cả hai. [Components](/docs/guide/directory-structure/components) có thể bị buộc chỉ chạy trên client. [Composables](/docs/guide/directory-structure/composables) và [utilities](/docs/guide/directory-structure/utils) được render dựa trên ngữ cảnh sử dụng của chúng.

**Lợi ích của server-side rendering:**
- **Hiệu suất**: Người dùng có thể truy cập ngay lập tức vào nội dung của trang vì browser có thể hiển thị nội dung tĩnh nhanh hơn nhiều so với nội dung được tạo bởi JavaScript. Đồng thời, Nuxt bảo tồn tính tương tác của ứng dụng web trong quá trình hydration.
- **Tối ưu hóa Công cụ Tìm kiếm**: Universal rendering cung cấp toàn bộ nội dung HTML của trang cho browser như một ứng dụng server cổ điển. Web crawler có thể lập chỉ mục trực tiếp nội dung của trang, điều này làm cho Universal rendering trở thành lựa chọn tuyệt vời cho bất kỳ nội dung nào mà bạn muốn lập chỉ mục nhanh chóng.

**Nhược điểm của server-side rendering:**
- **Ràng buộc phát triển:** Môi trường server và browser không cung cấp cùng các API, và có thể khó khăn để viết mã có thể chạy mượt mà trên cả hai phía. May mắn thay, Nuxt cung cấp hướng dẫn và các biến cụ thể để giúp bạn xác định nơi một đoạn mã được thực thi.
- **Chi phí:** Một server cần phải chạy để render các trang một cách tức thì. Điều này tăng thêm chi phí hàng tháng như bất kỳ server truyền thống nào. Tuy nhiên, các lệnh gọi server được giảm đáng kể nhờ universal rendering với browser tiếp quản việc điều hướng phía client. Việc giảm chi phí là có thể bằng cách tận dụng [edge-side-rendering](#edge-side-rendering).

Universal rendering rất linh hoạt và có thể phù hợp với hầu hết mọi trường hợp sử dụng, và đặc biệt thích hợp cho bất kỳ trang web hướng nội dung nào: **blog, trang web marketing, portfolio, trang thương mại điện tử, và marketplace.**

::tip
Để biết thêm ví dụ về việc viết mã Vue mà không có hydration mismatch, xem [Vue docs](https://vuejs.org/guide/scaling-up/ssr.html#hydration-mismatch).
::

::important
Khi import một thư viện dựa vào browser APIs và có tác dụng phụ, hãy đảm bảo component import nó chỉ được gọi phía client. Bundler không treeshake import của các module chứa tác dụng phụ.
::

## Client-Side Rendering

Ngay từ đầu, một ứng dụng Vue.js truyền thống được render trong browser (hoặc **client**). Sau đó, Vue.js tạo các element HTML sau khi browser tải xuống và phân tích tất cả mã JavaScript chứa hướng dẫn để tạo giao diện hiện tại.

![Users have to wait for the browser to download, parse and execute the JavaScript before seeing the page's content](/assets/docs/concepts/rendering/csr.svg)

**Lợi ích của client-side rendering:**
- **Tốc độ phát triển**: Khi làm việc hoàn toàn ở phía client, chúng ta không phải lo lắng về tính tương thích server của mã, ví dụ, bằng cách sử dụng các API chỉ dành cho browser như object `window`.
- **Rẻ hơn:** Chạy một server tăng thêm chi phí cơ sở hạ tầng vì bạn sẽ cần chạy trên một nền tảng hỗ trợ JavaScript. Chúng ta có thể host các ứng dụng chỉ client trên bất kỳ static server nào với file HTML, CSS, và JavaScript.
- **Offline:** Vì mã chạy hoàn toàn trong browser, nó có thể tiếp tục hoạt động tốt khi internet không khả dụng.

**Nhược điểm của client-side rendering:**
- **Hiệu suất**: Người dùng phải chờ browser tải xuống, phân tích và chạy file JavaScript. Tùy thuộc vào mạng cho phần tải xuống và thiết bị của người dùng cho việc phân tích và thực thi, điều này có thể mất một thời gian và ảnh hưởng đến trải nghiệm người dùng.
- **Tối ưu hóa Công cụ Tìm kiếm**: Lập chỉ mục và cập nhật nội dung được cung cấp qua client-side rendering mất nhiều thời gian hơn so với một tài liệu HTML được server-rendered. Điều này liên quan đến nhược điểm về hiệu suất mà chúng ta đã thảo luận, vì search engine crawler sẽ không chờ giao diện được render đầy đủ trong lần thử đầu tiên để lập chỉ mục trang. Nội dung của bạn sẽ mất nhiều thời gian hơn để hiển thị và cập nhật trong trang kết quả tìm kiếm với pure client-side rendering.

Client-side rendering là lựa chọn tốt cho các **ứng dụng web** có tính tương tác cao không cần lập chỉ mục hoặc những người dùng thường xuyên truy cập. Nó có thể tận dụng browser caching để bỏ qua giai đoạn tải xuống trong các lần truy cập tiếp theo, chẳng hạn như **SaaS, ứng dụng back-office, hoặc game online**.

Bạn có thể kích hoạt chỉ client-side rendering với Nuxt trong `nuxt.config.ts` của bạn:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false
})
```

::note
Nếu bạn sử dụng `ssr: false`, bạn cũng nên đặt một file HTML trong `~/spa-loading-template.html` với một số HTML mà bạn muốn sử dụng để render màn hình loading sẽ được render cho đến khi ứng dụng của bạn được hydrated.
:read-more{title="SPA Loading Template" to="/docs/api/configuration/nuxt-config#spaloadingtemplate"}
::

:video-accordion{title="Watch a video from Alexander Lichter about Building a plain SPA with Nuxt" videoId="7Lr0QTP1Ro8"}

### Deploying a Static Client-Rendered App

Nếu bạn deploy ứng dụng của mình lên [static hosting](/docs/getting-started/deployment#static-hosting) với lệnh `nuxt generate` hoặc `nuxt build --prerender`, thì theo mặc định, Nuxt sẽ render mỗi trang như một file HTML tĩnh riêng biệt.

::warning
Nếu bạn prerender ứng dụng của mình với lệnh `nuxt generate` hoặc `nuxt build --prerender`, thì bạn sẽ không thể sử dụng bất kỳ server endpoint nào vì không có server nào sẽ được bao gồm trong thư mục output của bạn. Nếu bạn cần chức năng server, hãy sử dụng `nuxt build` thay thế.
::

Nếu bạn đang sử dụng hoàn toàn client-side rendering, thì điều này có thể không cần thiết. Bạn có thể chỉ cần một file `index.html` duy nhất, cộng với `200.html` và `404.html` fallback, mà bạn có thể yêu cầu static web host của mình phục vụ cho tất cả các request.

Để đạt được điều này, chúng ta có thể thay đổi cách các route được prerendered. Chỉ cần thêm điều này vào [hooks của bạn](/docs/api/advanced/hooks#nuxt-hooks-build-time) trong `nuxt.config.ts` của bạn:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    'prerender:routes' ({ routes }) {
      routes.clear() // Không tạo bất kỳ route nào (trừ những cái mặc định)
    }
  },
})
```

Điều này sẽ tạo ra ba file:

- `index.html`
- `200.html`
- `404.html`

`200.html` và `404.html` có thể hữu ích cho nhà cung cấp hosting mà bạn đang sử dụng.

#### Skipping Client Fallback Generation

Khi prerendering một ứng dụng client-rendered, Nuxt sẽ tạo file `index.html`, `200.html` và `404.html` theo mặc định. Tuy nhiên, nếu bạn cần ngăn chặn bất kỳ (hoặc tất cả) những file này khỏi được tạo trong build của bạn, bạn có thể sử dụng hook `'prerender:generate'` từ [Nitro](/docs/getting-started/prerendering#prerendergenerate-nitro-hook).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false,
  nitro: {
    hooks: {
      'prerender:generate'(route) {
        const routesToSkip = ['/index.html', '/200.html', '/404.html']
        if (routesToSkip.includes(route.route)) {
          route.skip = true
        }
      }
    }
  }
})
```

## Hybrid Rendering

Hybrid rendering cho phép các quy tắc caching khác nhau cho mỗi route sử dụng **Route Rules** và quyết định cách server nên phản hồi với một request mới trên một URL nhất định.

Trước đây, mọi route/page của ứng dụng Nuxt và server phải sử dụng cùng một chế độ rendering, universal hoặc client-side. Trong nhiều trường hợp khác nhau, một số trang có thể được tạo tại build time, trong khi những trang khác nên được client-side rendered. Ví dụ, hãy nghĩ về một trang web nội dung với một phần admin. Mọi trang nội dung nên chủ yếu là tĩnh và được tạo một lần, nhưng phần admin yêu cầu đăng ký và hoạt động giống như một ứng dụng động hơn.

Nuxt bao gồm route rules và hỗ trợ hybrid rendering. Sử dụng route rules, bạn có thể định nghĩa các quy tắc cho một nhóm nuxt routes, thay đổi chế độ rendering hoặc gán một chiến lược cache dựa trên route!

Nuxt server sẽ tự động đăng ký middleware tương ứng và bọc routes với cache handlers sử dụng [Nitro caching layer](https://nitro.build/guide/cache).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    // Homepage pre-rendered tại build time
    '/': { prerender: true },
    // Products page được tạo theo yêu cầu, revalidates ở background, cached cho đến khi API response thay đổi
    '/products': { swr: true },
    // Product pages được tạo theo yêu cầu, revalidates ở background, cached trong 1 giờ (3600 giây)
    '/products/**': { swr: 3600 },
    // Blog posts page được tạo theo yêu cầu, revalidates ở background, cached trên CDN trong 1 giờ (3600 giây)
    '/blog': { isr: 3600 },
    // Blog post page được tạo theo yêu cầu một lần cho đến deployment tiếp theo, cached trên CDN
    '/blog/**': { isr: true },
    // Admin dashboard chỉ renders ở client-side
    '/admin/**': { ssr: false },
    // Thêm cors headers trên API routes
    '/api/**': { cors: true },
    // Redirects legacy urls
    '/old-page': { redirect: '/new-page' }
  }
})
```

### Route Rules

Các thuộc tính khác nhau mà bạn có thể sử dụng là:
- `redirect: string`{lang=ts} - Định nghĩa server-side redirects.
- `ssr: boolean`{lang=ts} - Vô hiệu hóa server-side rendering của HTML cho các phần của ứng dụng và làm chúng chỉ render trong browser với `ssr: false`
- `cors: boolean`{lang=ts} - Tự động thêm cors headers với `cors: true` - bạn có thể tùy chỉnh output bằng cách ghi đè với `headers`
- `headers: object`{lang=ts} - Thêm headers cụ thể vào các phần của trang web của bạn - ví dụ, assets của bạn
- `swr: number | boolean`{lang=ts} - Thêm cache headers vào server response và cache nó trên server hoặc reverse proxy cho một TTL có thể cấu hình (time to live). Preset `node-server` của Nitro có thể cache toàn bộ response. Khi TTL hết hạn, cached response sẽ được gửi trong khi trang sẽ được tái tạo ở background. Nếu true được sử dụng, một header `stale-while-revalidate` được thêm mà không có MaxAge.
- `isr: number | boolean`{lang=ts} - Hành vi giống như `swr` ngoại trừ việc chúng ta có thể thêm response vào CDN cache trên các nền tảng hỗ trợ điều này (hiện tại là Netlify hoặc Vercel). Nếu `true` được sử dụng, nội dung tồn tại cho đến deployment tiếp theo bên trong CDN.
- `prerender: boolean`{lang=ts} - Prerenders các routes tại build time và bao gồm chúng trong build của bạn như static assets
- `noScripts: boolean`{lang=ts} - Vô hiệu hóa rendering của Nuxt scripts và JS resource hints cho các phần của trang web của bạn.
- `appMiddleware: string | string[] | Record<string, boolean>`{lang=ts} - Cho phép bạn định nghĩa middleware nên hoặc không nên chạy cho page paths trong phần Vue app của ứng dụng của bạn (nghĩa là, không phải Nitro routes của bạn)

Bất cứ khi nào có thể, route rules sẽ được tự động áp dụng cho các quy tắc gốc của deployment platform để có hiệu suất tối ưu (Netlify và Vercel hiện được hỗ trợ).

::important
Lưu ý rằng Hybrid Rendering không khả dụng khi sử dụng [`nuxt generate`](/docs/api/commands/generate).
::

**Ví dụ:**

::card-group
  ::card
  ---
  icon: i-simple-icons-github
  title: Nuxt Vercel ISR
  to: https://github.com/danielroe/nuxt-vercel-isr
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Ví dụ về ứng dụng Nuxt với hybrid rendering được deploy trên Vercel.
  ::
::

## Edge-Side Rendering

Edge-Side Rendering (ESR) là một tính năng mạnh mẽ được giới thiệu trong Nuxt cho phép rendering ứng dụng Nuxt của bạn gần người dùng hơn thông qua edge servers của Content Delivery Network (CDN). Bằng cách tận dụng ESR, bạn có thể đảm bảo hiệu suất được cải thiện và giảm độ trễ, từ đó cung cấp trải nghiệm người dùng nâng cao.

Với ESR, quá trình rendering được đẩy đến 'edge' của mạng - các edge servers của CDN. Lưu ý rằng ESR là một deployment target hơn là một chế độ rendering thực tế.

Khi một request cho một trang được thực hiện, thay vì đi tất cả đường đến server gốc, nó bị chặn bởi edge server gần nhất. Server này tạo HTML cho trang và gửi nó trở lại cho người dùng. Quá trình này giảm thiểu khoảng cách vật lý mà dữ liệu phải di chuyển, **giảm độ trễ và tải trang nhanh hơn**.

Edge-side rendering có thể nhờ [Nitro](https://nitro.build/), [server engine](/docs/guide/concepts/server-engine) cung cấp sức mạnh cho Nuxt. Nó cung cấp hỗ trợ đa nền tảng cho Node.js, Deno, Cloudflare Workers, và nhiều hơn nữa.

Các nền tảng hiện tại mà bạn có thể tận dụng ESR là:
- [Cloudflare Pages](https://pages.cloudflare.com) với zero configuration sử dụng git integration và lệnh `nuxt build`
- [Vercel Edge Functions](https://vercel.com/features/edge-functions) sử dụng lệnh `nuxt build` và biến môi trường `NITRO_PRESET=vercel-edge`
- [Netlify Edge Functions](https://www.netlify.com/products/#netlify-edge-functions) sử dụng lệnh `nuxt build` và biến môi trường `NITRO_PRESET=netlify-edge`

Lưu ý rằng **Hybrid Rendering** có thể được sử dụng khi sử dụng Edge-Side Rendering với route rules.

Bạn có thể khám phá các ví dụ open source được deploy trên một số nền tảng được đề cập ở trên:
::card-group
  ::card
  ---
  icon: i-simple-icons-github
  title: Nuxt Todos Edge
  to: https://github.com/atinux/nuxt-todos-edge
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Ứng dụng todos với user authentication, SSR và SQLite.
  ::
  ::card
  ---
  icon: i-simple-icons-github
  title: Atinotes
  to: https://github.com/atinux/atinotes
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Trang web có thể chỉnh sửa với universal rendering dựa trên Cloudflare KV.
  ::
::

<!-- TODO: link to templates with ESR category for examples -->