---
title: 'Nuxt Lifecycle'
description: "Hiểu về lifecycle của ứng dụng Nuxt có thể giúp bạn có được cái nhìn sâu hơn về cách framework hoạt động, đặc biệt cho cả server-side và client-side rendering."
---

Mục tiêu của chương này là cung cấp một tổng quan high-level về các phần khác nhau của framework, thứ tự thực thi của chúng và cách chúng hoạt động cùng nhau.

## Server

Trên server, các bước sau được thực thi cho mọi request ban đầu đến ứng dụng của bạn:

### Step 1: Setup Nitro Server and Nitro Plugins (Once)

Nuxt được hỗ trợ bởi [Nitro](https://nitro.build/), một modern server engine.

Khi Nitro khởi động, nó sẽ initialize và thực thi các plugins dưới thư mục `/server/plugins`. Những plugins này có thể:
- Capture và handle các lỗi toàn ứng dụng.
- Register hooks thực thi khi Nitro tắt.
- Register hooks cho các sự kiện request lifecycle, chẳng hạn như modify responses.

::callout{icon="i-lucide-lightbulb"}
Nitro plugins chỉ được thực thi một lần khi server khởi động. Trong môi trường serverless, server boot trên mỗi incoming request, và Nitro plugins cũng vậy. Tuy nhiên, chúng không được awaited.
::

:read-more{to="/docs/guide/directory-structure/server#server-plugins"}

### Step 2: Nitro Server Middleware

Sau khi initialize Nitro server, middleware dưới `server/middleware/` được thực thi cho mọi request. Middleware có thể được sử dụng cho các tác vụ như authentication, logging, hoặc request transformation.

::warning
Trả về value từ middleware sẽ terminate request và gửi returned value làm response. Hành vi này thường nên tránh để đảm bảo xử lý request đúng cách!
::

:read-more{to="/docs/guide/directory-structure/server#server-middleware"}

### Step 3: Initialize Nuxt and Execute Nuxt App Plugins

Các Vue và Nuxt instances được tạo trước. Sau đó, Nuxt thực thi các server plugins của nó. Điều này bao gồm:
- Built-in plugins, chẳng hạn như Vue Router và `unhead`.
- Custom plugins nằm trong thư mục `plugins/`, bao gồm những plugins không có suffix (ví dụ: `myPlugin.ts`) và những plugins có suffix `.server` (ví dụ: `myServerPlugin.server.ts`).

Plugins thực thi theo một thứ tự cụ thể và có thể có dependencies lẫn nhau. Để biết thêm chi tiết, bao gồm thứ tự thực thi và parallelism, tham khảo [tài liệu Plugins](/docs/guide/directory-structure/plugins).

::callout{icon="i-lucide-lightbulb"}
Sau bước này, Nuxt gọi hook [`app:created`](/docs/api/advanced/hooks#app-hooks-runtime), có thể được sử dụng để thực thi logic bổ sung.
::

:read-more{to="/docs/guide/directory-structure/plugins"}

### Step 4: Route Validation

Sau khi initialize plugins và trước khi thực thi middleware, Nuxt gọi method `validate` nếu nó được define trong function `definePageMeta`. Method `validate`, có thể là synchronous hoặc asynchronous, thường được sử dụng để validate các dynamic route parameters.

- Function `validate` nên trả về `true` nếu các parameters hợp lệ.
- Nếu validation thất bại, nó nên trả về `false` hoặc một object chứa `statusCode` và/hoặc `statusMessage` để terminate request.

Để biết thêm thông tin, xem [tài liệu Route Validation](/docs/getting-started/routing#route-validation).

:read-more{to="/docs/getting-started/routing#route-validation"}

### Step 5: Execute Nuxt App Middleware

Middleware cho phép bạn chạy code trước khi navigate đến một route cụ thể. Nó thường được sử dụng cho các tác vụ như authentication, redirection, hoặc logging.

Trong Nuxt, có ba loại middleware:
- **Global route middleware**
- **Named route middleware**
- **Anonymous (or inline) route middleware**

Nuxt thực thi tất cả global middleware khi load trang ban đầu (cả trên server và client) và sau đó lại trước bất kỳ client-side navigation nào. Named và anonymous middleware chỉ được thực thi trên các routes được chỉ định trong middleware property của page(route) meta được define trong các page components tương ứng.

Để biết chi tiết về từng loại và ví dụ, xem [tài liệu Middleware](/docs/guide/directory-structure/middleware).

Bất kỳ redirection nào trên server sẽ dẫn đến việc gửi header `Location:` đến browser; browser sau đó thực hiện request mới đến location mới này. Tất cả application state sẽ được reset khi điều này xảy ra, trừ khi được persist trong một cookie.

:read-more{to="/docs/guide/directory-structure/middleware"}

### Step 6: Render Page and Components

Nuxt render page và các components của nó và fetch bất kỳ data cần thiết nào với `useFetch` và `useAsyncData` trong bước này. Vì không có dynamic updates và không có DOM operations xảy ra trên server, các Vue lifecycle hooks như `onBeforeMount`, `onMounted`, và các hooks tiếp theo **KHÔNG** được thực thi trong SSR.

Theo mặc định, Vue tạm dừng dependency tracking trong SSR để có hiệu suất tốt hơn.

::callout{icon="i-lucide-lightbulb"}
Không có reactivity ở phía server vì Vue SSR render ứng dụng từ trên xuống dưới như static HTML, làm cho việc quay lại và modify content đã được render trở nên không thể.
::

::important
Bạn nên tránh code tạo ra side effects cần cleanup trong root scope của `<script setup>`. Một ví dụ về những side effects như vậy là thiết lập timers với `setInterval`. Trong client-side only code chúng ta có thể thiết lập timer và sau đó tear it down trong `onBeforeUnmount` hoặc `onUnmounted`. Tuy nhiên, vì các unmount hooks sẽ không bao giờ được gọi trong SSR, các timers sẽ tồn tại mãi mãi. Để tránh điều này, hãy chuyển side-effect code của bạn vào `onMounted` thay thế.
::

::tip{icon="i-lucide-video" to="https://youtu.be/dZSNW07sO-A" target="_blank"}
Xem video từ Daniel Roe giải thích về Server Rendering và Global State.
::

### Step 7: Generate HTML Output

Sau khi tất cả data cần thiết được fetch và các components được render, Nuxt kết hợp các rendered components với settings từ `unhead` để tạo ra một HTML document hoàn chỉnh. HTML này, cùng với data liên quan, sau đó được gửi trả về client để hoàn thành quá trình SSR.

::callout{icon="i-lucide-lightbulb"}
Sau khi render Vue application thành HTML, Nuxt gọi hook [`app:rendered`](/docs/api/advanced/hooks#app-hooks-runtime).
::

::callout{icon="i-lucide-lightbulb"}
Trước khi finalize và gửi HTML, Nitro sẽ gọi hook [`render:html`](/docs/api/advanced/hooks#nitro-app-hooks-runtime-server-side). Hook này cho phép bạn manipulate HTML được tạo, chẳng hạn như inject thêm scripts hoặc modify meta tags.
::

## Client (browser)

Phần này của lifecycle được thực thi hoàn toàn trong browser, bất kể bạn đã chọn Nuxt mode nào.

### Step 1: Initialize Nuxt and Execute Nuxt App Plugins

Bước này tương tự như server-side execution và bao gồm cả built-in và custom plugins.

Custom plugins trong thư mục `plugins/`, như những plugins không có suffix (ví dụ: `myPlugin.ts`) và với suffix `.client` (ví dụ: `myClientPlugin.client.ts`), được thực thi ở phía client.

::callout{icon="i-lucide-lightbulb"}
Sau bước này, Nuxt gọi hook [`app:created`](/docs/api/advanced/hooks#app-hooks-runtime), có thể được sử dụng để thực thi logic bổ sung.
::

:read-more{to="/docs/guide/directory-structure/plugins"}

### Step 2: Route Validation

Bước này giống như server-side execution và bao gồm method `validate` nếu được define trong function `definePageMeta`.

### Step 3: Execute Nuxt App Middleware

Nuxt middleware chạy trên cả server và client. Nếu bạn muốn code nhất định chạy trong các môi trường cụ thể, hãy cân nhắc chia nó bằng cách sử dụng `import.meta.client` cho client và `import.meta.server` cho server.

:read-more{to="/docs/guide/directory-structure/middleware#when-middleware-runs"}

### Step 4: Mount Vue Application and Hydration

Gọi `app.mount('#__nuxt')` mount Vue application vào DOM. Nếu ứng dụng sử dụng SSR hoặc SSG mode, Vue thực hiện bước hydration để làm cho client-side application trở nên interactive. Trong hydration, Vue tạo lại ứng dụng (loại trừ [Server Components](/docs/guide/directory-structure/components#server-components)), match từng component với DOM nodes tương ứng của nó, và attach DOM event listeners.

Để đảm bảo hydration đúng cách, điều quan trọng là duy trì tính nhất quán giữa data trên server và client. Đối với API requests, khuyến nghị sử dụng `useAsyncData`, `useFetch`, hoặc các composables SSR-friendly khác. Những methods này đảm bảo rằng data được fetch ở phía server được tái sử dụng trong hydration, tránh các requests lặp lại. Bất kỳ requests mới nào chỉ nên được trigger sau hydration, ngăn ngừa hydration errors.

::callout{icon="i-lucide-lightbulb"}
Trước khi mount Vue application, Nuxt gọi hook [`app:beforeMount`](/docs/api/advanced/hooks#app-hooks-runtime).
::

::callout{icon="i-lucide-lightbulb"}
Sau khi mount Vue application, Nuxt gọi hook [`app:mounted`](/docs/api/advanced/hooks#app-hooks-runtime).
::

### Step 5: Vue Lifecycle

Không giống như trên server, browser thực thi đầy đủ [Vue lifecycle](https://vuejs.org/guide/essentials/lifecycle).