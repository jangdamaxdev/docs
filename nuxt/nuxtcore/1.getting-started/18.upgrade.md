---
title: Upgrade Guide
description: 'Tìm hiểu cách nâng cấp lên phiên bản Nuxt mới nhất.'
navigation.icon: i-lucide-circle-arrow-up
---

## Nâng cấp Nuxt

### Bản phát hành mới nhất

Để nâng cấp Nuxt lên [bản phát hành mới nhất](https://github.com/nuxt/nuxt/releases), hãy sử dụng lệnh `nuxt upgrade`.

::code-group{sync="pm"}

```bash [npm]
npx nuxt upgrade
```

```bash [yarn]
yarn nuxt upgrade
```

```bash [pnpm]
pnpm nuxt upgrade
```

```bash [bun]
bun x nuxt upgrade
```

::

### Kênh phát hành hàng đêm

Để sử dụng bản build Nuxt mới nhất và kiểm tra các tính năng trước khi chúng được phát hành, hãy đọc về hướng dẫn [kênh phát hành hàng đêm](/docs/guide/going-further/nightly-release-channel).

## Di chuyển sang Nuxt 4

Nuxt 4 bao gồm các cải tiến và thay đổi đáng kể. Hướng dẫn này sẽ giúp bạn di chuyển ứng dụng Nuxt 3 hiện tại sang Nuxt 4.

Đầu tiên, nâng cấp lên Nuxt 4:

::code-group{sync="pm"}

```bash [npm]
npm install nuxt@^4.0.0
```

```bash [yarn]
yarn add nuxt@^4.0.0
```

```bash [pnpm]
pnpm add nuxt@^4.0.0
```

```bash [bun]
bun add nuxt@^4.0.0
```

::

Sau khi nâng cấp, hầu hết các hành vi của Nuxt 4 giờ đây là mặc định. Tuy nhiên, một số tính năng vẫn có thể được cấu hình nếu bạn cần duy trì khả năng tương thích ngược trong quá trình di chuyển.

Các phần sau đây mô tả chi tiết về những thay đổi chính và việc di chuyển cần thiết khi nâng cấp lên Nuxt 4.

Các thay đổi phá vỡ hoặc đáng kể được ghi lại bên dưới cùng với các bước di chuyển và tùy chọn cấu hình có sẵn.

### Di chuyển sử dụng Codemods

Để tạo điều kiện cho quá trình nâng cấp, chúng tôi đã hợp tác với nhóm [Codemod](https://github.com/codemod-com/codemod) để tự động hóa nhiều bước di chuyển với một số codemods mã nguồn mở.

::note
Nếu bạn gặp bất kỳ vấn đề nào, vui lòng báo cáo chúng cho nhóm Codemod với `npx codemod feedback` 🙏
::

Để có danh sách đầy đủ các codemods của Nuxt 4, thông tin chi tiết về từng codemod, nguồn của chúng và các cách khác nhau để chạy chúng, hãy truy cập [Codemod Registry](https://go.codemod.com/codemod-registry).

Bạn có thể chạy tất cả các codemods được đề cập trong hướng dẫn này bằng cách sử dụng `codemod` recipe sau:

::code-group

```bash [npm]
npx codemod@latest nuxt/4/migration-recipe
```

```bash [yarn]
yarn dlx codemod@latest nuxt/4/migration-recipe
```

```bash [pnpm]
pnpm dlx codemod@latest nuxt/4/migration-recipe
```

```bash [bun]
bun x codemod@latest nuxt/4/migration-recipe
```

::

Lệnh này sẽ thực thi tất cả các codemods theo trình tự, với tùy chọn bỏ chọn bất kỳ codemod nào mà bạn không muốn chạy. Mỗi codemod cũng được liệt kê bên dưới cùng với thay đổi tương ứng của nó và có thể được thực thi độc lập.

### Cấu trúc thư mục mới

🚦 **Mức độ tác động**: Đáng kể

Nuxt giờ đây mặc định sử dụng cấu trúc thư mục mới, với khả năng tương thích ngược (vì vậy nếu Nuxt phát hiện bạn đang sử dụng cấu trúc cũ, chẳng hạn như thư mục `pages/` ở cấp cao nhất, cấu trúc mới này sẽ không áp dụng).

👉 [Xem RFC đầy đủ](https://github.com/nuxt/nuxt/issues/26444)

#### Những gì đã thay đổi

* `srcDir` mặc định mới của Nuxt là `app/` theo mặc định, và hầu hết mọi thứ đều được giải quyết từ đó.
* `serverDir` giờ đây mặc định là `<rootDir>/server` thay vì `<srcDir>/server`
* `layers/`, `modules/` và `public/` được giải quyết tương đối so với `<rootDir>` theo mặc định
* nếu sử dụng [Nuxt Content v2.13+](https://github.com/nuxt/content/pull/2649), `content/` được giải quyết tương đối so với `<rootDir>`
* một `dir.app` mới được thêm vào, đây là thư mục chúng tôi tìm kiếm `router.options.ts` và `spa-loading-template.html` - mặc định này là `<srcDir>/`

<details>

<summary>Một ví dụ về cấu trúc thư mục v4.</summary>

```sh
.output/
.nuxt/
app/
  assets/
  components/
  composables/
  layouts/
  middleware/
  pages/
  plugins/
  utils/
  app.config.ts
  app.vue
  router.options.ts
content/
layers/
modules/
node_modules/
public/
shared/
server/
  api/
  middleware/
  plugins/
  routes/
  utils/
nuxt.config.ts
```

::note
Với cấu trúc mới này, alias `~` giờ đây trỏ đến thư mục `app/` theo mặc định (`srcDir` của bạn). Điều này có nghĩa là `~/components` giải quyết thành `app/components/`, `~/pages` thành `app/pages/`, v.v.
::

</details>

👉 Để biết thêm chi tiết, xem [PR thực hiện thay đổi này](https://github.com/nuxt/nuxt/pull/27029).

#### Lý do thay đổi

1. **Hiệu suất** - đặt tất cả mã của bạn trong thư mục gốc của repo gây ra vấn đề với các thư mục `.git/` và `node_modules/` được quét/bao gồm bởi FS watchers có thể làm chậm đáng kể việc khởi động trên các hệ điều hành không phải Mac.
1. **Tính an toàn kiểu IDE** - `server/` và phần còn lại của ứng dụng của bạn đang chạy trong hai ngữ cảnh hoàn toàn khác nhau với các import toàn cục khác nhau có sẵn, và đảm bảo `server/` không nằm _trong_ cùng thư mục với phần còn lại của ứng dụng là bước đầu tiên quan trọng để đảm bảo bạn nhận được auto-completes tốt trong IDE.

:video-accordion{title="Xem video từ Vue School về cấu trúc thư mục mới" videoId="1031028378" platform="vimeo"}

#### Bước di chuyển

1. Tạo một thư mục mới có tên `app/`.
1. Di chuyển các thư mục `assets/`, `components/`, `composables/`, `layouts/`, `middleware/`, `pages/`, `plugins/` và `utils/` của bạn vào dưới nó, cũng như `app.vue`, `error.vue`, `app.config.ts`. Nếu bạn có `app/router-options.ts` hoặc `app/spa-loading-template.html`, các đường dẫn này vẫn giữ nguyên.
1. Đảm bảo các thư mục `nuxt.config.ts`, `content/`, `layers/`, `modules/`, `public/` và `server/` của bạn vẫn ở bên ngoài thư mục `app/`, trong thư mục gốc của dự án.
1. Nhớ cập nhật bất kỳ tệp cấu hình của bên thứ ba nào để hoạt động với cấu trúc thư mục mới, chẳng hạn như cấu hình `tailwindcss` hoặc `eslint` của bạn (nếu cần - `@nuxtjs/tailwindcss` sẽ tự động cấu hình `tailwindcss` một cách chính xác).

::tip
Bạn có thể tự động hóa việc di chuyển này bằng cách chạy `npx codemod@latest nuxt/4/file-structure`
::

Tuy nhiên, việc di chuyển _không bắt buộc_. Nếu bạn muốn giữ cấu trúc thư mục hiện tại, Nuxt sẽ tự động phát hiện nó. (Nếu không, vui lòng tạo issue.) Ngoại lệ duy nhất là nếu bạn _đã_ có một `srcDir` tùy chỉnh. Trong trường hợp này, bạn nên biết rằng các thư mục `modules/`, `public/` và `server/` của bạn sẽ được giải quyết từ `rootDir` thay vì từ `srcDir` tùy chỉnh của bạn. Bạn có thể ghi đè điều này bằng cách cấu hình `dir.modules`, `dir.public` và `serverDir` nếu cần.

Bạn cũng có thể buộc cấu trúc thư mục v3 với cấu hình sau:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // Điều này hoàn nguyên srcDir mặc định mới từ `app` về thư mục gốc của bạn
  srcDir: '.',
  // Điều này chỉ định tiền tố thư mục cho `router.options.ts` và `spa-loading-template.html`
  dir: {
    app: 'app'
  }
})
```

### Lớp Data Fetching đơn lẻ

🚦 **Mức độ tác động**: Vừa phải

#### Những gì đã thay đổi

Hệ thống data fetching của Nuxt (`useAsyncData` và `useFetch`) đã được tổ chức lại đáng kể để có hiệu suất và tính nhất quán tốt hơn:

1. **Shared refs cho cùng key**: Tất cả các lời gọi đến `useAsyncData` hoặc `useFetch` với cùng key giờ đây chia sẻ cùng `data`, `error` và `status` refs. Điều này có nghĩa là việc tất cả các lời gọi với key rõ ràng không được có các tùy chọn `deep`, `transform`, `pick`, `getCachedData` hoặc `default` xung đột là quan trọng.

2. **Kiểm soát nhiều hơn đối với `getCachedData`**: Hàm `getCachedData` giờ đây được gọi mỗi khi dữ liệu được lấy, ngay cả khi điều này do watcher hoặc gọi `refreshNuxtData` gây ra. (Trước đây, dữ liệu mới luôn được lấy và hàm này không được gọi trong những trường hợp này.) Để cho phép kiểm soát nhiều hơn về thời điểm sử dụng dữ liệu đã cache và khi nào refetch, hàm giờ đây nhận một đối tượng context với nguyên nhân của yêu cầu.

3. **Hỗ trợ reactive key**: Bạn giờ đây có thể sử dụng computed refs, plain refs hoặc getter functions làm keys, điều này cho phép tự động refetching dữ liệu (và lưu trữ dữ liệu riêng biệt).

4. **Dọn dẹp dữ liệu**: Khi component cuối cùng sử dụng dữ liệu được lấy với `useAsyncData` bị unmount, Nuxt sẽ loại bỏ dữ liệu đó để tránh việc sử dụng bộ nhớ tăng liên tục.

#### Lý do thay đổi

Những thay đổi này được thực hiện để cải thiện việc sử dụng bộ nhớ và tăng tính nhất quán với các trạng thái loading qua các lời gọi của `useAsyncData`.

#### Bước di chuyển

1. **Kiểm tra các tùy chọn không nhất quán**: Xem lại bất kỳ component nào sử dụng cùng key với các tùy chọn hoặc fetch functions khác nhau.

   ```ts
   // Điều này giờ đây sẽ kích hoạt cảnh báo
   const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { deep: false })
   const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { deep: true })
   ```

   Có thể có lợi khi trích xuất bất kỳ lời gọi nào đến `useAsyncData` chia sẻ key rõ ràng (và có tùy chọn tùy chỉnh) vào composable riêng của chúng:

   ```ts [composables/useUserData.ts]
   export function useUserData(userId: string) {
     return useAsyncData(
       `user-${userId}`,
       () => fetchUser(userId),
       { 
         deep: true,
         transform: (user) => ({ ...user, lastAccessed: new Date() })
       }
     )
   }
   ```

2. **Cập nhật các implementations của `getCachedData`**:

   ```diff
   useAsyncData('key', fetchFunction, {
   -  getCachedData: (key, nuxtApp) => {
   -    return cachedData[key]
   -  }
   +  getCachedData: (key, nuxtApp, ctx) => {
   +    // ctx.cause - có thể là 'initial' | 'refresh:hook' | 'refresh:manual' | 'watch'
   +    
   +    // Ví dụ: Không sử dụng cache khi refresh thủ công
   +    if (ctx.cause === 'refresh:manual') return undefined
   +    
   +    return cachedData[key]
   +  }
   })
   ```

Thay vào đó, hiện tại, bạn có thể tắt hành vi này với:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    granularCachedData: false,
    purgeCachedData: false
  }
})
```

### Thứ tự tải Module được sửa chữa trong Layers

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Thứ tự mà các modules được tải khi sử dụng [Nuxt layers](/docs/guide/going-further/layers) đã được sửa chữa. Trước đây, các modules từ project root được tải trước các modules từ extended layers, điều này ngược lại với hành vi mong đợi.

Giờ đây các modules được tải theo thứ tự đúng:

1. **Layer modules trước** (theo thứ tự extend - deeper layers trước)
2. **Project modules cuối** (ưu tiên cao nhất)

Điều này ảnh hưởng đến cả:
* Các modules được định nghĩa trong mảng `modules` trong `nuxt.config.ts`
* Các modules được tự động khám phá từ thư mục `modules/`

#### Lý do thay đổi

Thay đổi này đảm bảo rằng:
* Các extended layers có ưu tiên thấp hơn dự án tiêu thụ
* Thứ tự thực thi module phù hợp với mô hình kế thừa layer trực quan
* Cấu hình module và hooks hoạt động như mong đợi trong các thiết lập đa layer

#### Bước di chuyển

**Hầu hết các dự án sẽ không cần thay đổi**, vì điều này sửa chữa thứ tự tải để phù hợp với hành vi mong đợi.

Tuy nhiên, nếu dự án của bạn đã dựa vào thứ tự không đúng trước đây, bạn có thể cần:

1. **Xem lại các dependencies của module**: Kiểm tra xem có modules nào phụ thuộc vào thứ tự tải cụ thể không
2. **Điều chỉnh cấu hình module**: Nếu các modules được cấu hình để làm việc xung quanh thứ tự không đúng
3. **Kiểm tra kỹ lưỡng**: Đảm bảo tất cả chức năng hoạt động như mong đợi với thứ tự được sửa chữa

Ví dụ về thứ tự đúng mới:
```ts
// Layer: my-layer/nuxt.config.ts
export default defineNuxtConfig({
  modules: ['layer-module-1', 'layer-module-2']
})

// Project: nuxt.config.ts
export default defineNuxtConfig({
  extends: ['./my-layer'],
  modules: ['project-module-1', 'project-module-2']
})

// Thứ tự tải (đã sửa chữa):
// 1. layer-module-1
// 2. layer-module-2  
// 3. project-module-1 (có thể ghi đè layer modules)
// 4. project-module-2 (có thể ghi đè layer modules)
```

Nếu bạn gặp vấn đề với các dependencies thứ tự module do cần đăng ký một hook, hãy xem xét sử dụng [`modules:done` hook](/docs/guide/going-further/modules#custom-hooks) cho các modules cần gọi một hook. Hook này được chạy sau khi tất cả các modules khác đã được tải, có nghĩa là việc sử dụng nó là an toàn.

👉 Xem [PR #31507](https://github.com/nuxt/nuxt/pull/31507) và [issue #25719](https://github.com/nuxt/nuxt/issues/25719) để biết thêm chi tiết.

### Khử trùng Route Metadata

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Có thể thiết lập một số metadata route bằng `definePageMeta`, chẳng hạn như `name`, `path`, v.v. Trước đây chúng có sẵn cả trên route và trên route metadata (ví dụ, `route.name` và `route.meta.name`).

Giờ đây, chúng chỉ có thể truy cập được trên đối tượng route.

#### Lý do thay đổi

Đây là kết quả của việc kích hoạt `experimental.scanPageMeta` theo mặc định, và là một tối ưu hóa hiệu suất.

#### Bước di chuyển

Việc di chuyển nên đơn giản:

```diff
  const route = useRoute()
  
- console.log(route.meta.name)
+ console.log(route.name)
```

### Tên Component được chuẩn hóa

🚦 **Mức độ tác động**: Vừa phải

Vue giờ đây sẽ tạo ra các tên component phù hợp với mô hình Nuxt cho việc đặt tên component.

#### Những gì đã thay đổi

Theo mặc định, nếu bạn chưa thiết lập nó thủ công, Vue sẽ gán một tên component phù hợp với tên tệp của component.

```bash [Directory structure]
├─ components/
├── SomeFolder/
├──── MyComponent.vue
```

Trong trường hợp này, tên component sẽ là `MyComponent`, theo như Vue quan tâm. Nếu bạn muốn sử dụng `<KeepAlive>` với nó, hoặc xác định nó trong Vue DevTools, bạn sẽ cần sử dụng tên này.

Nhưng để auto-import nó, bạn sẽ cần sử dụng `SomeFolderMyComponent`.

Với thay đổi này, hai giá trị này sẽ khớp, và Vue sẽ tạo ra một tên component phù hợp với mô hình Nuxt cho việc đặt tên component.

#### Bước di chuyển

Đảm bảo rằng bạn sử dụng tên đã cập nhật trong bất kỳ bài test nào sử dụng `findComponent` từ `@vue/test-utils` và trong bất kỳ `<KeepAlive>` nào phụ thuộc vào tên của component.

Thay vào đó, hiện tại, bạn có thể tắt hành vi này với:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    normalizeComponentNames: false
  }
})
```

### Unhead v2

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

[Unhead](https://unhead.unjs.io/), được sử dụng để tạo các thẻ `<head>`, đã được cập nhật lên phiên bản 2. Mặc dù chủ yếu tương thích nhưng nó bao gồm một số thay đổi phá vỡ cho các API cấp thấp hơn.

* Các props đã loại bỏ: `vmid`, `hid`, `children`, `body`.
* Promise input không còn được hỗ trợ.
* Các thẻ giờ đây được sắp xếp bằng Capo.js theo mặc định.

#### Bước di chuyển

Các thay đổi trên nên có tác động tối thiểu đến ứng dụng của bạn.

Nếu bạn có vấn đề, bạn nên xác minh:

* Bạn không sử dụng bất kỳ props nào đã bị loại bỏ.

```diff
useHead({
  meta: [{ 
    name: 'description', 
    // meta tags không cần vmid, hoặc key    
-   vmid: 'description' 
-   hid: 'description'
  }]
})
```

* Nếu bạn đang sử dụng [Template Params](https://unhead.unjs.io/docs/head/guides/plugins/template-params) hoặc [Alias Tag Sorting](https://unhead.unjs.io/docs/head/guides/plugins/alias-sorting), bạn sẽ cần rõ ràng opt in vào các tính năng này ngay bây giờ.

```ts
import { TemplateParamsPlugin, AliasSortingPlugin } from '@unhead/vue/plugins'

export default defineNuxtPlugin({
  setup() {
    const unhead = injectHead()
    unhead.use(TemplateParamsPlugin)
    unhead.use(AliasSortingPlugin)
  }
})
```

Mặc dù không bắt buộc, nhưng được khuyến nghị cập nhật bất kỳ imports nào từ `@unhead/vue` sang `#imports` hoặc `nuxt/app`.

```diff
-import { useHead } from '@unhead/vue'
+import { useHead } from '#imports'
```

Nếu bạn vẫn có vấn đề, bạn có thể hoàn nguyên về hành vi v1 bằng cách kích hoạt cấu hình `head.legacy`.

```ts
export default defineNuxtConfig({
  unhead: {
    legacy: true,
  }
})
```

### Vị trí DOM mới cho SPA Loading Screen

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Khi render một trang chỉ dành cho client (với `ssr: false`), chúng tôi tùy ý render một màn hình loading (từ `~/app/spa-loading-template.html` - lưu ý rằng điều này cũng đã thay đổi thành `~/spa-loading-template.html` trong Nuxt 4), bên trong Nuxt app root:

```html
<div id="__nuxt">
  <!-- spa loading template -->
</div>
```

Giờ đây, chúng tôi mặc định render template cùng với Nuxt app root:

```html
<div id="__nuxt"></div>
<!-- spa loading template -->
```

#### Lý do thay đổi

Điều này cho phép spa loading template vẫn còn trong DOM cho đến khi Vue app suspense resolves, ngăn chặn flash màu trắng.

#### Bước di chuyển

Nếu bạn đang nhắm mục tiêu spa loading template với CSS hoặc `document.queryElement`, bạn sẽ cần cập nhật các selectors của mình. Cho mục đích này, bạn có thể sử dụng các tùy chọn cấu hình mới `app.spaLoaderTag` và `app.spaLoaderAttrs`.

Thay vào đó, bạn có thể hoàn nguyên về hành vi trước đây với:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    spaLoadingTemplateLocation: 'within',
  }
})
```

### `error.data` được Parse

🚦 **Mức độ tác động**: Tối thiểu

Có thể throw một error với thuộc tính `data`, nhưng điều này không được parsed. Giờ đây, nó được parsed và có sẵn trong đối tượng `error`. Mặc dù là một bản sửa lỗi, nhưng về mặt kỹ thuật đây là một thay đổi phá vỡ nếu bạn đã dựa vào hành vi trước đây và tự parse nó.

#### Bước di chuyển

Cập nhật `error.vue` tùy chỉnh của bạn để loại bỏ bất kỳ parsing bổ sung nào của `error.data`:

```diff
  <script setup lang="ts">
  import type { NuxtError } from '#app'

  const props = defineProps({
    error: Object as () => NuxtError
  })

- const data = JSON.parse(error.data)
+ const data = error.data
  </script>
```

### Inline Styles chi tiết hơn

🚦 **Mức độ tác động**: Vừa phải

Nuxt giờ đây sẽ chỉ inline styles cho các Vue components, không phải CSS toàn cục.

#### Những gì đã thay đổi

Trước đây, Nuxt sẽ inline tất cả CSS, bao gồm global styles, và loại bỏ các phần tử `<link>` đến các tệp CSS riêng biệt. Giờ đây, Nuxt sẽ chỉ làm điều này cho các Vue components (trước đây tạo ra các chunks CSS riêng biệt). Chúng tôi nghĩ đây là sự cân bằng tốt hơn trong việc giảm các yêu cầu mạng riêng biệt (giống như trước đây, sẽ không có các yêu cầu riêng biệt cho các tệp `.css` riêng lẻ theo từng trang hoặc từng component khi tải ban đầu), cũng như cho phép caching của một tệp CSS toàn cục duy nhất và giảm kích thước tải xuống document của yêu cầu ban đầu.

#### Bước di chuyển

Tính năng này có thể cấu hình đầy đủ và bạn có thể hoàn nguyên về hành vi trước đây bằng cách thiết lập `inlineStyles: true` để inline global CSS cũng như per-component CSS.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  features: {
    inlineStyles: true
  }
})
```

### Quét Page Meta sau Resolution

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Chúng tôi giờ đây quét page metadata (được định nghĩa trong `definePageMeta`) _sau khi_ gọi hook `pages:extend` thay vì trước đó.

#### Lý do thay đổi

Điều này nhằm cho phép quét metadata cho các pages mà người dùng muốn thêm vào trong `pages:extend`. Chúng tôi vẫn cung cấp cơ hội thay đổi hoặc ghi đè page metadata trong một hook `pages:resolved` mới.

#### Bước di chuyển

Nếu bạn muốn ghi đè page metadata, hãy làm điều đó trong `pages:resolved` thay vì trong `pages:extend`.

```diff
  export default defineNuxtConfig({
    hooks: {
-     'pages:extend'(pages) {
+     'pages:resolved'(pages) {
        const myPage = pages.find(page => page.path === '/')
        myPage.meta ||= {}
        myPage.meta.layout = 'overridden-layout'
      }
    }
  })
```

Thay vào đó, bạn có thể hoàn nguyên về hành vi trước đây với:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    scanPageMeta: true
  }
})
```

### Chia sẻ Prerender Data

🚦 **Mức độ tác động**: Trung bình

#### Những gì đã thay đổi

Chúng tôi đã kích hoạt một tính năng thử nghiệm trước đây để chia sẻ dữ liệu từ các lời gọi `useAsyncData` và `useFetch`, qua các pages khác nhau. Xem [PR gốc](https://github.com/nuxt/nuxt/pull/24894).

#### Lý do thay đổi

Tính năng này tự động chia sẻ payload _data_ giữa các pages được prerender. Điều này có thể dẫn đến cải thiện hiệu suất đáng kể khi prerender các sites sử dụng `useAsyncData` hoặc `useFetch` và fetch cùng dữ liệu trong các pages khác nhau.

Ví dụ, nếu site của bạn yêu cầu lời gọi `useFetch` cho mọi page (ví dụ, để lấy dữ liệu điều hướng cho menu, hoặc cài đặt site từ CMS), dữ liệu này sẽ chỉ được lấy một lần khi prerender page đầu tiên sử dụng nó, và sau đó được cached để sử dụng khi prerender các pages khác.

#### Bước di chuyển

Đảm bảo rằng bất kỳ key duy nhất nào của dữ liệu của bạn luôn có thể resolve thành cùng dữ liệu. Ví dụ, nếu bạn đang sử dụng `useAsyncData` để fetch dữ liệu liên quan đến một page cụ thể, bạn nên cung cấp key phù hợp duy nhất với dữ liệu đó. (`useFetch` nên làm điều này tự động cho bạn.)

```ts [app/pages/test/[slug\].vue]
// Điều này sẽ không an toàn trong một dynamic page (ví dụ `[slug].vue`) vì route slug tạo ra sự khác biệt
// với dữ liệu được lấy, nhưng Nuxt không thể biết điều đó vì nó không được phản ánh trong key.
const route = useRoute()
const { data } = await useAsyncData(async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
// Thay vào đó, bạn nên sử dụng key xác định duy nhất dữ liệu được lấy.
const { data } = await useAsyncData(route.params.slug, async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
```

Thay vào đó, bạn có thể tắt tính năng này với:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    sharedPrerenderData: false
  }
})
```

### Giá trị `data` và `error` mặc định trong `useAsyncData` và `useFetch`

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Các đối tượng `data` và `error` được trả về từ `useAsyncData` giờ đây sẽ mặc định là `undefined`.

#### Lý do thay đổi

Trước đây `data` được khởi tạo thành `null` nhưng được reset trong `clearNuxtData` thành `undefined`. `error` được khởi tạo thành `null`. Thay đổi này nhằm mang lại tính nhất quán cao hơn.

#### Bước di chuyển

Nếu bạn đang kiểm tra xem `data.value` hoặc `error.value` có phải `null` không, bạn có thể cập nhật các kiểm tra này để kiểm tra `undefined` thay thế.

::tip
Bạn có thể tự động hóa bước này bằng cách chạy `npx codemod@latest nuxt/4/default-data-error-value`
::

Nếu bạn gặp bất kỳ vấn đề nào, bạn có thể hoàn nguyên về hành vi trước đây với:

```ts twoslash [nuxt.config.ts]
// @errors: 2353
export default defineNuxtConfig({
  experimental: {
    defaults: {
      useAsyncData: {
        value: 'null',
        errorValue: 'null'
      }
    }
  }
})
```

Vui lòng báo cáo issue nếu bạn làm điều này, vì chúng tôi không có kế hoạch giữ điều này có thể cấu hình.

### Loại bỏ các giá trị `boolean` deprecated cho tùy chọn `dedupe` khi gọi `refresh` trong `useAsyncData` và `useFetch`

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Trước đây có thể truyền `dedupe: boolean` đến `refresh`. Đây là các aliases của `cancel` (`true`) và `defer` (`false`).

```ts twoslash [app.vue]
// @errors: 2322
const { refresh } = await useAsyncData(async () => ({ message: 'Hello, Nuxt!' }))

async function refreshData () {
  await refresh({ dedupe: true })
}
```

#### Lý do thay đổi

Những aliases này đã được loại bỏ, để có sự rõ ràng hơn.

Vấn đề nảy sinh khi thêm `dedupe` như một tùy chọn vào `useAsyncData`, và chúng tôi đã loại bỏ các giá trị boolean vì chúng kết thúc là _đối lập_.

`refresh({ dedupe: false })` có nghĩa là **không _hủy_ các yêu cầu hiện có để ưu tiên cái mới này**. Nhưng việc truyền `dedupe: true` trong tùy chọn của `useAsyncData` có nghĩa là **không thực hiện bất kỳ yêu cầu mới nào nếu có yêu cầu đang chờ hiện tại.** (Xem [PR](https://github.com/nuxt/nuxt/pull/24564#pullrequestreview-1764584361).)

#### Bước di chuyển

Việc di chuyển nên đơn giản:

```diff
  const { refresh } = await useAsyncData(async () => ({ message: 'Hello, Nuxt 3!' }))
  
  async function refreshData () {
-   await refresh({ dedupe: true })
+   await refresh({ dedupe: 'cancel' })

-   await refresh({ dedupe: false })
+   await refresh({ dedupe: 'defer' })
  }
```

::tip
Bạn có thể tự động hóa bước này bằng cách chạy `npx codemod@latest nuxt/4/deprecated-dedupe-value`
::

### Tôn trọng defaults khi xóa `data` trong `useAsyncData` và `useFetch`

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Nếu bạn cung cấp giá trị `default` tùy chỉnh cho `useAsyncData`, giờ đây giá trị này sẽ được sử dụng khi gọi `clear` hoặc `clearNuxtData` và nó sẽ được reset về giá trị mặc định thay vì đơn giản bỏ thiết lập.

#### Lý do thay đổi

Thường người dùng thiết lập một giá trị trống phù hợp, chẳng hạn như mảng trống, để tránh cần kiểm tra `null`/`undefined` khi lặp qua nó. Điều này nên được tôn trọng khi reset/xóa dữ liệu.

### Căn chỉnh giá trị `pending` trong `useAsyncData` và `useFetch`

🚦 **Mức độ tác động**: Trung bình

Đối tượng `pending` được trả về từ `useAsyncData`, `useFetch`, `useLazyAsyncData` và `useLazyFetch` giờ đây là một computed property chỉ `true` khi `status` cũng đang pending.

#### Những gì đã thay đổi

Giờ đây, khi `immediate: false` được truyền, `pending` sẽ là `false` cho đến khi yêu cầu đầu tiên được thực hiện. Đây là sự thay đổi từ hành vi trước đây, khi `pending` luôn là `true` cho đến khi yêu cầu đầu tiên được thực hiện.

#### Lý do thay đổi

Điều này căn chỉnh ý nghĩa của `pending` với thuộc tính `status`, cũng là `pending` khi yêu cầu đang trong quá trình thực hiện.

#### Bước di chuyển

Nếu bạn dựa vào thuộc tính `pending`, hãy đảm bảo logic của bạn tính đến hành vi mới khi `pending` sẽ chỉ là `true` khi status cũng đang pending.

```diff
  <template>
-   <div v-if="!pending">
+   <div v-if="status === 'success'">
      <p>Data: {{ data }}</p>
    </div>
    <div v-else>
      <p>Loading...</p>
    </div>
  </template>
  <script setup lang="ts">
  const { data, pending, execute, status } = await useAsyncData(() => fetch('/api/data'), {
    immediate: false
  })
  onMounted(() => execute())
  </script>
```

Thay vào đó, bạn có thể tạm thời hoàn nguyên về hành vi trước đây với:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    pendingWhenIdle: true
  }
})
```

### Hành vi thay đổi Key trong `useAsyncData` và `useFetch`

🚦 **Mức độ tác động**: Trung bình

#### Những gì đã thay đổi

Khi sử dụng reactive keys trong `useAsyncData` hoặc `useFetch`, Nuxt tự động refetch dữ liệu khi key thay đổi. Khi `immediate: false` được thiết lập, `useAsyncData` sẽ chỉ fetch dữ liệu khi key thay đổi nếu dữ liệu đã được fetch một lần.

Trước đây, `useFetch` có hành vi hơi khác. Nó sẽ luôn fetch dữ liệu khi key thay đổi.

Giờ đây, `useFetch` và `useAsyncData` hành xử nhất quán - bằng cách chỉ fetch dữ liệu khi key thay đổi nếu dữ liệu đã được fetch một lần.

#### Lý do thay đổi

Điều này đảm bảo hành vi nhất quán giữa `useAsyncData` và `useFetch`, và ngăn chặn các fetches không mong muốn. Nếu bạn đã thiết lập `immediate: false`, thì bạn phải gọi `refresh` hoặc `execute` hoặc dữ liệu sẽ không bao giờ được fetch trong `useFetch` hoặc `useAsyncData`.

#### Bước di chuyển

Thay đổi này nói chung nên cải thiện hành vi mong đợi, nhưng nếu bạn mong đợi việc thay đổi key hoặc options của một `useFetch` không immediate, giờ đây bạn sẽ cần kích hoạt nó thủ công lần đầu tiên.

```diff
  const id = ref('123')
  const { data, execute } = await useFetch('/api/test', {
    query: { id },
    immediate: false
  )
+ watch(id, () => execute(), { once: true })
```

Để opt out khỏi hành vi này:

```ts
// Hoặc toàn cục trong Nuxt config của bạn
export default defineNuxtConfig({
  experimental: {
    alwaysRunFetchOnKeyChange: true
  }
})
```

### Shallow Data Reactivity trong `useAsyncData` và `useFetch`

🚦 **Mức độ tác động**: Tối thiểu

Đối tượng `data` được trả về từ `useAsyncData`, `useFetch`, `useLazyAsyncData` và `useLazyFetch` giờ đây là một `shallowRef` thay vì một `ref`.

#### Những gì đã thay đổi

Khi dữ liệu mới được fetch, bất cứ thứ gì phụ thuộc vào `data` vẫn sẽ là reactive vì toàn bộ đối tượng được thay thế. Nhưng nếu mã của bạn thay đổi một thuộc tính _trong_ cấu trúc dữ liệu đó, điều này sẽ không kích hoạt bất kỳ reactivity nào trong ứng dụng của bạn.

#### Lý do thay đổi

Điều này mang lại cải thiện hiệu suất **đáng kể** cho các đối tượng và mảng lồng sâu vì Vue không cần theo dõi từng thuộc tính/mảng đơn lẻ để sửa đổi. Trong hầu hết các trường hợp, `data` cũng nên là immutable.

#### Bước di chuyển

Trong hầu hết các trường hợp, không cần bước di chuyển nào, nhưng nếu bạn dựa vào reactivity của đối tượng data thì bạn có hai tùy chọn:

1. Bạn có thể chi tiết opt in vào deep reactivity trên cơ sở từng composable:
   ```diff
   - const { data } = useFetch('/api/test')
   + const { data } = useFetch('/api/test', { deep: true })
   ```
2. Bạn có thể thay đổi hành vi mặc định trên cơ sở toàn dự án (không được khuyến nghị):
   ```ts twoslash [nuxt.config.ts]
   export default defineNuxtConfig({
     experimental: {
       defaults: {
         useAsyncData: {
           deep: true
         }
       }
     }
   })
   ```

::tip
Nếu cần, bạn có thể tự động hóa bước này bằng cách chạy `npx codemod@latest nuxt/4/shallow-function-reactivity`
::

### Đường dẫn Watch tuyệt đối trong `builder:watch`

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Hook `builder:watch` của Nuxt giờ đây emit một path tuyệt đối thay vì tương đối so với `srcDir` dự án của bạn.

#### Lý do thay đổi

Điều này cho phép chúng tôi hỗ trợ theo dõi các paths bên ngoài `srcDir` của bạn, và cung cấp hỗ trợ tốt hơn cho layers và các mẫu phức tạp khác.

#### Bước di chuyển

Chúng tôi đã chủ động di chuyển các modules Nuxt công khai mà chúng tôi biết sử dụng hook này. Xem [issue #25339](https://github.com/nuxt/nuxt/issues/25339).

Tuy nhiên, nếu bạn là tác giả module sử dụng hook `builder:watch` và muốn duy trì khả năng tương thích ngược/tiến, bạn có thể sử dụng mã sau để đảm bảo mã của bạn hoạt động giống nhau trong cả Nuxt v3 và Nuxt v4:

```diff
+ import { relative, resolve } from 'node:fs'
  // ...
  nuxt.hook('builder:watch', async (event, path) => {
+   path = relative(nuxt.options.srcDir, resolve(nuxt.options.srcDir, path))
    // ...
  })
```

::tip
Bạn có thể tự động hóa bước này bằng cách chạy `npx codemod@latest nuxt/4/absolute-watch-path`
::

### Loại bỏ đối tượng `window.__NUXT__`

#### Những gì đã thay đổi

Chúng tôi đang loại bỏ đối tượng toàn cục `window.__NUXT__` sau khi ứng dụng hoàn thành hydration.

#### Lý do thay đổi

Điều này mở đường cho các mẫu multi-app ([#21635](https://github.com/nuxt/nuxt/issues/21635)) và cho phép chúng tôi tập trung vào một cách duy nhất để truy cập dữ liệu Nuxt app - `useNuxtApp()`.

#### Bước di chuyển

Dữ liệu vẫn có sẵn, nhưng có thể được truy cập với `useNuxtApp().payload`:

```diff
- console.log(window.__NUXT__)
+ console.log(useNuxtApp().payload)
```

### Quét index thư mục

🚦 **Mức độ tác động**: Trung bình

#### Những gì đã thay đổi

Các thư mục con trong thư mục `middleware/` của bạn cũng được quét để tìm các tệp `index` và chúng giờ đây cũng được đăng ký làm middleware trong dự án của bạn.

#### Lý do thay đổi

Nuxt tự động quét một số thư mục, bao gồm `middleware/` và `plugins/`.

Các thư mục con trong thư mục `plugins/` của bạn được quét để tìm các tệp `index` và chúng tôi muốn làm cho hành vi này nhất quán giữa các thư mục được quét.

#### Bước di chuyển

Có lẽ không cần di chuyển gì nhưng nếu bạn muốn hoàn nguyên về hành vi trước đây, bạn có thể thêm một hook để lọc ra những middleware này:

```ts
export default defineNuxtConfig({
  hooks: {
    'app:resolve'(app) {
      app.middleware = app.middleware.filter(mw => !/\/index\.[^/]+$/.test(mw.path))
    }
  }
})
```

### Thay đổi Template Compilation

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Trước đây, Nuxt sử dụng `lodash/template` để biên dịch các templates nằm trên hệ thống tệp bằng định dạng/cú pháp tệp `.ejs`.

Ngoài ra, chúng tôi cung cấp một số utilities template (`serialize`, `importName`, `importSources`) có thể được sử dụng để tạo mã trong những templates này, giờ đây đang được loại bỏ.

#### Lý do thay đổi

Trong Nuxt v3 chúng tôi chuyển sang cú pháp 'ảo' với hàm `getContents()` linh hoạt và hiệu suất hơn nhiều.

Ngoài ra, `lodash/template` đã có một loạt các vấn đề bảo mật. Những vấn đề này không thực sự áp dụng cho các dự án Nuxt vì nó được sử dụng tại thời điểm build, không phải runtime, và bởi mã đáng tin cậy. Tuy nhiên, chúng vẫn xuất hiện trong các kiểm tra bảo mật. Hơn nữa, `lodash` là một dependency nặng và không được sử dụng bởi hầu hết các dự án.

Cuối cùng, việc cung cấp các hàm serialization mã trực tiếp trong Nuxt là không lý tưởng. Thay vào đó, chúng tôi duy trì các dự án như [unjs/knitwork](http://github.com/unjs/knitwork) có thể là dependencies của dự án bạn, và nơi các vấn đề bảo mật có thể được báo cáo/giải quyết trực tiếp mà không yêu cầu nâng cấp Nuxt.

#### Bước di chuyển

Chúng tôi đã tạo các PR để cập nhật các modules sử dụng cú pháp EJS, nhưng nếu bạn cần tự làm điều này, bạn có ba lựa chọn tương thích ngược/tiến:

* Di chuyển logic string interpolation của bạn trực tiếp vào `getContents()`.
* Sử dụng hàm tùy chỉnh để xử lý việc thay thế, như trong https://github.com/nuxt-modules/color-mode/pull/240.
* Sử dụng `es-toolkit/compat` (thay thế drop-in cho lodash template), như một dependency của dự án _bạn_ thay vì Nuxt:

```diff
+ import { readFileSync } from 'node:fs'
+ import { template } from 'es-toolkit/compat'
  // ...
  addTemplate({
    fileName: 'appinsights-vue.js'
    options: { /* some options */ },
-   src: resolver.resolve('./runtime/plugin.ejs'),
+   getContents({ options }) {
+     const contents = readFileSync(resolver.resolve('./runtime/plugin.ejs'), 'utf-8')
+     return template(contents)({ options })
+   },
  })
```

Cuối cùng, nếu bạn đang sử dụng các template utilities (`serialize`, `importName`, `importSources`), bạn có thể thay thế chúng như sau với các utilities từ `knitwork`:

```ts
import { genDynamicImport, genImport, genSafeVariableName } from 'knitwork'

const serialize = (data: any) => JSON.stringify(data, null, 2).replace(/"{(.+)}"(?=,?$)/gm, r => JSON.parse(r).replace(/^{(.*)}$/, '$1'))

const importSources = (sources: string | string[], { lazy = false } = {}) => {
  return toArray(sources).map((src) => {
    if (lazy) {
      return `const ${genSafeVariableName(src)} = ${genDynamicImport(src, { comment: `webpackChunkName: ${JSON.stringify(src)}` })}`
    }
    return genImport(src, genSafeVariableName(src))
  }).join('\n')
}

const importName = genSafeVariableName
```

::tip
Bạn có thể tự động hóa bước này bằng cách chạy `npx codemod@latest nuxt/4/template-compilation-changes`
::

### Thay đổi cấu hình TypeScript mặc định

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

`compilerOptions.noUncheckedIndexedAccess` giờ đây là `true` thay vì `false`.

#### Lý do thay đổi

Thay đổi này là phần tiếp theo của [cập nhật cấu hình 3.12](https://github.com/nuxt/nuxt/pull/27485) trước đây khi chúng tôi cải thiện các mặc định của mình, chủ yếu tuân thủ [khuyến nghị của TotalTypeScript](https://www.totaltypescript.com/tsconfig-cheat-sheet).

#### Bước di chuyển

Có hai cách tiếp cận:

1. Chạy typecheck trên ứng dụng của bạn và sửa bất kỳ lỗi mới nào (được khuyến nghị).

2. Ghi đè mặc định mới trong `nuxt.config.ts` của bạn:

   <!-- @case-police-ignore tsConfig -->

   ```ts
   export default defineNuxtConfig({
     typescript: {
       tsConfig: {
         compilerOptions: {
           noUncheckedIndexedAccess: false
         }
       }
     }
   })
   ```

### Chia tách cấu hình TypeScript

🚦 **Mức độ tác động**: Tối thiểu

#### What Changed

Nuxt hiện tại tạo ra các cấu hình TypeScript riêng biệt cho các ngữ cảnh khác nhau để cung cấp trải nghiệm kiểm tra kiểu tốt hơn:

1. **Các file cấu hình TypeScript mới**: Nuxt hiện tại tạo ra các cấu hình TypeScript bổ sung:
   * `.nuxt/tsconfig.app.json` - Cho mã ứng dụng của bạn (các component Vue, composables, v.v.)
   * `.nuxt/tsconfig.server.json` - Cho mã phía server của bạn (thư mục Nitro/server)  
   * `.nuxt/tsconfig.node.json` - Cho mã build-time của bạn (modules, `nuxt.config.ts`, v.v.)
   * `.nuxt/tsconfig.shared.json` - Cho mã được chia sẻ giữa ngữ cảnh app và server (như types và các tiện ích không phụ thuộc môi trường)
   * `.nuxt/tsconfig.json` - Cấu hình legacy để tương thích ngược

2. **Tương thích ngược**: Các dự án hiện tại mở rộng `.nuxt/tsconfig.json` sẽ tiếp tục hoạt động như trước.

3. **Opt-in project references**: Các dự án mới hoặc những dự án muốn kiểm tra kiểu tốt hơn có thể áp dụng tính năng project references của TypeScript.

4. **Kiểm tra kiểu theo ngữ cảnh cụ thể**: Mỗi ngữ cảnh hiện có các tùy chọn compiler phù hợp và includes/excludes cho môi trường cụ thể của nó.

5. **Tùy chọn `typescript.nodeTsConfig` mới**: Bạn hiện có thể tùy chỉnh cấu hình TypeScript cho mã build-time Node.js.

#### Reasons for Change

Thay đổi này mang lại một số lợi ích:

1. **An toàn kiểu tốt hơn**: Mỗi ngữ cảnh (app, server, build-time) được kiểm tra kiểu phù hợp với các globals và APIs cụ thể theo ngữ cảnh.
2. **Trải nghiệm IDE được cải thiện**: IntelliSense và báo lỗi tốt hơn cho các phần khác nhau của codebase.
3. **Tách biệt rõ ràng hơn**: Mã server sẽ không đề xuất sai các API phía client và ngược lại.
4. **Hiệu suất**: TypeScript có thể kiểm tra mã hiệu quả hơn với các cấu hình được phạm vi hóa đúng cách.

Ví dụ, auto-imports không khả dụng trong `nuxt.config.ts` của bạn (nhưng trước đây điều này không được TypeScript báo cờ). Và trong khi IDEs nhận ra ngữ cảnh riêng biệt được gợi ý bởi `tsconfig.json` trong thư mục `server/` của bạn, điều này không được phản ánh trong kiểm tra kiểu (yêu cầu một bước riêng biệt).

#### Migration Steps

**Không cần migration** - các dự án hiện tại sẽ tiếp tục hoạt động như trước.

Tuy nhiên, để tận dụng việc kiểm tra kiểu được cải thiện, bạn có thể opt-in vào phương pháp project references mới:

1. **Cập nhật `tsconfig.json` gốc của bạn** để sử dụng project references:

   ```json
   {
     "files": [],
     "references": [
       { "path": "./.nuxt/tsconfig.app.json" },
       { "path": "./.nuxt/tsconfig.server.json" },
       { "path": "./.nuxt/tsconfig.shared.json" },
       { "path": "./.nuxt/tsconfig.node.json" }
     ]
   }
   ```

2. **Xóa bất kỳ file `tsconfig.json` server thủ công** (như `server/tsconfig.json`) đã mở rộng `.nuxt/tsconfig.server.json`.

3. **Cập nhật scripts kiểm tra kiểu của bạn** để sử dụng build flag cho project references:

   ```diff
   - "typecheck": "nuxt prepare && vue-tsc --noEmit"
   + "typecheck": "nuxt prepare && vue-tsc -b --noEmit"
   ```

4. **Di chuyển tất cả type augmentations vào ngữ cảnh phù hợp**:
   * Nếu bạn đang augment types cho ngữ cảnh app, di chuyển các file vào thư mục `app/`.
   * Nếu bạn đang augment types cho ngữ cảnh server, di chuyển các file vào thư mục `server/`.
   * Nếu bạn đang augment types được **chia sẻ giữa app và server**, di chuyển các file vào thư mục `shared/`.

    ::warning
    Augmenting types từ bên ngoài thư mục `app/`, `server/`, hoặc `shared/` sẽ không hoạt động với thiết lập project references mới.
    ::

5. **Cấu hình tùy chọn Node.js TypeScript** nếu cần:
   <!-- @case-police-ignore tsConfig -->

   ```ts
   export default defineNuxtConfig({
     typescript: {
       // Tùy chỉnh cấu hình TypeScript cho app/server
       tsConfig: {
         compilerOptions: {
           strict: true
         }
       },
       // Tùy chỉnh cấu hình TypeScript cho build-time  
       nodeTsConfig: {
         compilerOptions: {
           strict: true
         }
       }
     }
   })
   ```

6. **Cập nhật bất kỳ CI/build scripts** chạy kiểm tra TypeScript để đảm bảo chúng sử dụng phương pháp project references mới.

Cấu hình mới cung cấp an toàn kiểu và IntelliSense tốt hơn cho các dự án opt-in, đồng thời duy trì tương thích ngược đầy đủ cho các thiết lập hiện tại.

### Removal of Experimental Features

🚦 **Impact Level**: Tối thiểu

#### What Changed

Bốn tính năng thử nghiệm không còn có thể cấu hình trong Nuxt 4:

* `experimental.treeshakeClientOnly` sẽ là `true` (mặc định từ v3.0)
* `experimental.configSchema` sẽ là `true` (mặc định từ v3.3)
* `experimental.polyfillVueUseHead` sẽ là `false` (mặc định từ v3.4)
* `experimental.respectNoSSRHeader` sẽ là `false` (mặc định từ v3.4)
* `vite.devBundler` không còn có thể cấu hình - nó sẽ sử dụng `vite-node` theo mặc định

#### Reasons for Change

Các tùy chọn này đã được đặt thành giá trị hiện tại trong một thời gian và chúng tôi không có lý do để tin rằng chúng cần phải vẫn có thể cấu hình.

#### Migration Steps

* `polyfillVueUseHead` có thể được triển khai trong user-land với [plugin này](https://github.com/nuxt/nuxt/blob/f209158352b09d1986aa320e29ff36353b91c358/packages/nuxt/src/head/runtime/plugins/vueuse-head-polyfill.ts#L10-L11)

* `respectNoSSRHeader` có thể được triển khai trong user-land với [server middleware](https://github.com/nuxt/nuxt/blob/c660b39447f0d5b8790c0826092638d321cd6821/packages/nuxt/src/core/runtime/nitro/no-ssr.ts#L8-L9)

### Removal of Top-Level `generate` Configuration

🚦 **Impact Level**: Tối thiểu

#### What Changed

Tùy chọn cấu hình `generate` cấp cao nhất không còn khả dụng trong Nuxt 4. Điều này bao gồm tất cả các thuộc tính của nó:

* `generate.exclude` - để loại trừ các routes khỏi prerendering
* `generate.routes` - để chỉ định các routes cần prerender

#### Reasons for Change

Cấu hình `generate` cấp cao là di sản từ Nuxt 2. Chúng tôi đã hỗ trợ `nitro.prerender` trong một thời gian và đó là cách ưa thích để cấu hình prerendering trong Nuxt 3+.

#### Migration Steps

Thay thế cấu hình `generate` bằng các tùy chọn `nitro.prerender` tương ứng:

```diff
export default defineNuxtConfig({
- generate: {
-   exclude: ['/admin', '/private'],
-   routes: ['/sitemap.xml', '/robots.txt']
- }
+ nitro: {
+   prerender: {
+     ignore: ['/admin', '/private'],
+     routes: ['/sitemap.xml', '/robots.txt']
+   }
+ }
})
```

::read-more{to="https://nitro.build/config#prerender"}
Đọc thêm về các tùy chọn cấu hình prerender của Nitro.
::

## Nuxt 2 vs. Nuxt 3+

Trong bảng dưới đây, có một so sánh nhanh giữa 3 phiên bản của Nuxt:

Feature / Version        | Nuxt 2          | Nuxt Bridge      | Nuxt 3+
-------------------------|-----------------|------------------|---------
Vue                      | 2               | 2                | 3
Stability                | 😊 Ổn định      | 😊 Ổn định         | 😊 Ổn định
Performance              | 🏎 Nhanh        | ✈️ Nhanh hơn          | 🚀 Nhanh nhất
Nitro Engine             | ❌             | ✅                | ✅
ESM support              | 🌙 Một phần     | 👍 Tốt hơn         | ✅
TypeScript               | ☑️ Opt-in       | 🚧 Một phần        | ✅
Composition API          | ❌             | 🚧 Một phần        | ✅
Options API              | ✅             | ✅                | ✅
Components Auto Import   | ✅             | ✅                | ✅
`<script setup>` syntax  | ❌             | 🚧 Một phần        | ✅
Auto Imports             | ❌             | ✅                | ✅
webpack                  | 4              | 4                 | 5
Vite                     | ⚠️ Một phần      | 🚧 Một phần        | ✅
Nuxt CLI                 | ❌ Cũ         | ✅ nuxt           | ✅ nuxt
Static sites             | ✅             | ✅                | ✅

## Nuxt 2 to Nuxt 3+

Hướng dẫn migration cung cấp so sánh từng bước các tính năng của Nuxt 2 với các tính năng Nuxt 3+ và hướng dẫn để thích ứng ứng dụng hiện tại của bạn.

::read-more{to="/docs/migration/overview"}
Kiểm tra **hướng dẫn migration từ Nuxt 2 sang Nuxt 3**.
::

## Nuxt 2 to Nuxt Bridge

Nếu bạn muốn từ từ migration ứng dụng Nuxt 2 của mình sang Nuxt 3, bạn có thể sử dụng Nuxt Bridge. Nuxt Bridge là một lớp tương thích cho phép bạn sử dụng các tính năng Nuxt 3+ trong Nuxt 2 với cơ chế opt-in.

::read-more{to="/docs/bridge/overview"}
**Migration từ Nuxt 2 sang Nuxt Bridge**
::