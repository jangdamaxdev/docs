---
title: 'Data Fetching'
description: Nuxt provides composables to handle data fetching within your application.
navigation.icon: i-lucide-cable
---

Nuxt đi kèm với hai composable và một thư viện tích hợp để thực hiện data-fetching trong môi trường trình duyệt hoặc server: `useFetch`, [`useAsyncData`](/docs/api/composables/use-async-data) và `$fetch`.

Tóm lại:

- [`$fetch`](/docs/api/utils/dollarfetch) là cách đơn giản nhất để tạo một network request.
- [`useFetch`](/docs/api/composables/use-fetch) là một wrapper xung quanh `$fetch` chỉ fetch data một lần trong [universal rendering](/docs/guide/concepts/rendering#universal-rendering).
- [`useAsyncData`](/docs/api/composables/use-async-data) tương tự như `useFetch` nhưng cung cấp kiểm soát chi tiết hơn.

Cả `useFetch` và `useAsyncData` đều chia sẻ một tập hợp chung các tùy chọn và patterns mà chúng ta sẽ chi tiết trong các phần cuối.

## The need for `useFetch` and `useAsyncData`

Nuxt là một framework có thể chạy mã isomorphic (hoặc universal) trong cả môi trường server và client. Nếu hàm [`$fetch`](/docs/api/utils/dollarfetch) được sử dụng để thực hiện data fetching trong setup function của một Vue component, điều này có thể khiến data được fetch hai lần, một lần trên server (để render HTML) và một lần nữa trên client (khi HTML được hydrated). Điều này có thể gây ra vấn đề hydration, tăng thời gian để tương tác và gây ra hành vi không thể đoán trước.

Các composable [`useFetch`](/docs/api/composables/use-fetch) và [`useAsyncData`](/docs/api/composables/use-async-data) giải quyết vấn đề này bằng cách đảm bảo rằng nếu một API call được thực hiện trên server, data sẽ được chuyển tiếp đến client trong payload.

Payload là một JavaScript object có thể truy cập thông qua [`useNuxtApp().payload`](/docs/api/composables/use-nuxt-app#payload). Nó được sử dụng trên client để tránh refetching cùng một data khi mã được thực thi trong trình duyệt [trong quá trình hydration](/docs/guide/concepts/rendering#universal-rendering).

::tip
Sử dụng [Nuxt DevTools](https://devtools.nuxt.com) để kiểm tra data này trong **Payload tab**.
::

```vue [app.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/data')

async function handleFormSubmit() {
  const res = await $fetch('/api/submit', {
    method: 'POST',
    body: {
      // My form data
    }
  })
}
</script>

<template>
  <div v-if="data == undefined">
    No data
  </div>
  <div v-else>
    <form @submit="handleFormSubmit">
      <!-- form input tags -->
    </form>
  </div>
</template>
```

Trong ví dụ trên, `useFetch` sẽ đảm bảo rằng request sẽ xảy ra trong server và được chuyển tiếp đúng cách đến trình duyệt. `$fetch` không có cơ chế như vậy và là lựa chọn tốt hơn để sử dụng khi request chỉ được thực hiện từ trình duyệt.

### Suspense

Nuxt sử dụng component [`<Suspense>`](https://vuejs.org/guide/built-ins/suspense) của Vue để ngăn navigation trước khi mọi async data có sẵn cho view. Các data fetching composable có thể giúp bạn tận dụng tính năng này và sử dụng những gì phù hợp nhất trên cơ sở mỗi call.

::note
Bạn có thể thêm [`<NuxtLoadingIndicator>`](/docs/api/components/nuxt-loading-indicator) để thêm thanh tiến trình giữa các navigation trang.
::

## `$fetch`

Nuxt bao gồm thư viện [ofetch](https://github.com/unjs/ofetch), và được auto-imported dưới dạng alias `$fetch` trên toàn cầu trong ứng dụng của bạn.

```vue twoslash [pages/todos.vue]
<script setup lang="ts">
async function addTodo() {
  const todo = await $fetch('/api/todos', {
    method: 'POST',
    body: {
      // My todo data
    }
  })
}
</script>
```

::warning
Hãy cẩn thận rằng việc chỉ sử dụng `$fetch` sẽ không cung cấp [network calls de-duplication và navigation prevention](#the-need-for-usefetch-and-useasyncdata). :br
Được khuyến nghị sử dụng `$fetch` cho các tương tác phía client (dựa trên sự kiện) hoặc kết hợp với [`useAsyncData`](#useasyncdata) khi fetching data component ban đầu.
::

::read-more{to="/docs/api/utils/dollarfetch"}
Read more about `$fetch`.
::

### Pass Client Headers to the API

Khi gọi `useFetch` trên server, Nuxt sẽ sử dụng [`useRequestFetch`](/docs/api/composables/use-request-fetch) để proxy client headers và cookies (ngoại trừ các headers không được dành để forward, như `host`).

```vue
<script setup lang="ts">
const { data } = await useFetch('/api/echo');
</script>
```

```ts
// /api/echo.ts
export default defineEventHandler(event => parseCookies(event))
```

Hoặc, ví dụ bên dưới cho thấy cách sử dụng [`useRequestHeaders`](/docs/api/composables/use-request-headers) để truy cập và gửi cookies đến API từ một server-side request (bắt nguồn từ client). Sử dụng một isomorphic `$fetch` call, chúng ta đảm bảo rằng API endpoint có quyền truy cập vào cùng một `cookie` header ban đầu được gửi bởi trình duyệt của người dùng. Điều này chỉ cần thiết nếu bạn không sử dụng `useFetch`.

```vue
<script setup lang="ts">
const headers = useRequestHeaders(['cookie'])

async function getCurrentUser() {
  return await $fetch('/api/me', { headers })
}
</script>
```

::tip
Bạn cũng có thể sử dụng [`useRequestFetch`](/docs/api/composables/use-request-fetch) để proxy headers đến call một cách tự động.
::

::caution
Hãy rất cẩn thận trước khi proxy headers đến một external API và chỉ bao gồm các headers mà bạn cần. Không phải tất cả headers đều an toàn để được bypassed và có thể giới thiệu hành vi không mong muốn. Đây là danh sách các headers phổ biến mà KHÔNG nên được proxy:

- `host`, `accept`
- `content-length`, `content-md5`, `content-type`
- `x-forwarded-host`, `x-forwarded-port`, `x-forwarded-proto`
- `cf-connecting-ip`, `cf-ray`
::

## `useFetch`

Composable [`useFetch`](/docs/api/composables/use-fetch) sử dụng `$fetch` bên trong để thực hiện các network call an toàn SSR trong setup function.

```vue twoslash [app.vue]
<script setup lang="ts">
const { data: count } = await useFetch('/api/count')
</script>

<template>
  <p>Page visits: {{ count }}</p>
</template>
```

Composable này là một wrapper xung quanh composable [`useAsyncData`](/docs/api/composables/use-async-data) và utility `$fetch`.

:video-accordion{title="Watch a video from Alexander Lichter to avoid using useFetch the wrong way" videoId="njsGVmcWviY"}

:read-more{to="/docs/api/composables/use-fetch"}

:link-example{to="/docs/examples/features/data-fetching"}
## `useAsyncData`

Composable `useAsyncData` chịu trách nhiệm bao bọc async logic và trả về kết quả khi nó được resolved.

::tip
`useFetch(url)` gần như tương đương với `useAsyncData(url, () => event.$fetch(url))`. :br
Đó là developer experience sugar cho trường hợp sử dụng phổ biến nhất. (Bạn có thể tìm hiểu thêm về `event.fetch` tại [`useRequestFetch`](/docs/api/composables/use-request-fetch).)
::

:video-accordion{title="Watch a video from Alexander Lichter to dig deeper into the difference between useFetch and useAsyncData" videoId="0X-aOpSGabA"}

Có một số trường hợp khi việc sử dụng composable [`useFetch`](/docs/api/composables/use-fetch) không phù hợp, ví dụ khi một CMS hoặc bên thứ ba cung cấp query layer riêng của họ. Trong trường hợp này, bạn có thể sử dụng [`useAsyncData`](/docs/api/composables/use-async-data) để bao bọc các call của mình và vẫn giữ các lợi ích được cung cấp bởi composable.

```vue [pages/users.vue]
<script setup lang="ts">
const { data, error } = await useAsyncData('users', () => myGetFunction('users'))

// Điều này cũng có thể:
const { data, error } = await useAsyncData(() => myGetFunction('users'))
</script>
```

::note
Đối số đầu tiên của [`useAsyncData`](/docs/api/composables/use-async-data) là một key duy nhất được sử dụng để cache response của đối số thứ hai, querying function. Key này có thể được bỏ qua bằng cách truyền trực tiếp querying function, key sẽ được tự động tạo.
:br :br
Vì key được tự động tạo chỉ tính đến file và line nơi `useAsyncData` được gọi, nên khuyến nghị luôn tạo key riêng của bạn để tránh hành vi không mong muốn, như khi bạn đang tạo custom composable riêng bao bọc `useAsyncData`.
:br :br
Đặt một key có thể hữu ích để chia sẻ cùng một data giữa các component bằng cách sử dụng [`useNuxtData`](/docs/api/composables/use-nuxt-data) hoặc để [refresh data cụ thể](/docs/api/utils/refresh-nuxt-data#refresh-specific-data).
::

```vue [pages/users/[id\\].vue]
<script setup lang="ts">
const { id } = useRoute().params

const { data, error } = await useAsyncData(`user:${id}`, () => {
  return myGetFunction('users', { id })
})
</script>
```

Composable `useAsyncData` là cách tuyệt vời để bao bọc và chờ nhiều `$fetch` request hoàn thành, sau đó xử lý kết quả.

```vue
<script setup lang="ts">
const { data: discounts, status } = await useAsyncData('cart-discount', async () => {
  const [coupons, offers] = await Promise.all([
    $fetch('/cart/coupons'),
    $fetch('/cart/offers')
  ])

  return { coupons, offers }
})
// discounts.value.coupons
// discounts.value.offers
</script>
```

::note
`useAsyncData` dành cho fetching và caching data, không phải triggering side effects như gọi Pinia actions, vì điều này có thể gây ra hành vi không mong muốn như thực thi lặp lại với giá trị nullish. Nếu bạn cần trigger side effects, hãy sử dụng utility [`callOnce`](/docs/api/utils/call-once) để làm như vậy.

```vue
<script setup lang="ts">
const offersStore = useOffersStore()

// bạn không thể làm điều này
await useAsyncData(() => offersStore.getOffer(route.params.slug))
</script>
```
::

::read-more{to="/docs/api/composables/use-async-data"}
Read more about `useAsyncData`.
::

## Return Values

`useFetch` và `useAsyncData` có cùng return values được liệt kê bên dưới.

- `data`: kết quả của asynchronous function được truyền vào.
- `refresh`/`execute`: một hàm có thể được sử dụng để refresh data được trả về bởi hàm `handler`.
- `clear`: một hàm có thể được sử dụng để đặt `data` thành `undefined` (hoặc giá trị của `options.default()` nếu được cung cấp), đặt `error` thành `undefined`, đặt `status` thành `idle`, và đánh dấu bất kỳ request nào đang pending là cancelled.
- `error`: một error object nếu data fetching thất bại.
- `status`: một chuỗi chỉ ra trạng thái của data request (`"idle"`, `"pending"`, `"success"`, `"error"`).

::note
`data`, `error` và `status` là Vue refs có thể truy cập bằng `.value` trong `<script setup>`
::

Theo mặc định, Nuxt chờ đến khi một `refresh` hoàn thành trước khi nó có thể được thực thi lại.

::note
Nếu bạn chưa fetch data trên server (ví dụ, với `server: false`), thì data _sẽ không_ được fetched cho đến khi hydration hoàn thành. Điều này có nghĩa là ngay cả khi bạn await `useFetch` trên client-side, `data` sẽ vẫn là null trong `<script setup>`.
::

## Options

[`useAsyncData`](/docs/api/composables/use-async-data) và [`useFetch`](/docs/api/composables/use-fetch) trả về cùng object type và chấp nhận một tập hợp chung các tùy chọn như đối số cuối cùng của chúng. Chúng có thể giúp bạn kiểm soát hành vi của composable, chẳng hạn như navigation blocking, caching hoặc execution.

### Lazy

Theo mặc định, data fetching composable sẽ chờ resolution của asynchronous function của chúng trước khi điều hướng đến trang mới bằng cách sử dụng Suspense của Vue. Tính năng này có thể được bỏ qua trên client-side navigation với tùy chọn `lazy`. Trong trường hợp đó, bạn sẽ phải xử lý loading state một cách thủ công bằng cách sử dụng giá trị `status`.

```vue twoslash [app.vue]
<script setup lang="ts">
const { status, data: posts } = useFetch('/api/posts', {
  lazy: true
})
</script>

<template>
  <!-- bạn sẽ cần xử lý loading state -->
  <div v-if="status === 'pending'">
    Loading ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- do something -->
    </div>
  </div>
</template>
```

Bạn có thể sử dụng [`useLazyFetch`](/docs/api/composables/use-lazy-fetch) và `useLazyAsyncData` như các phương thức tiện lợi để thực hiện tương tự.

```vue twoslash
<script setup lang="ts">
const { status, data: posts } = useLazyFetch('/api/posts')
</script>
```

::read-more{to="/docs/api/composables/use-lazy-fetch"}
Read more about `useLazyFetch`.
::

::read-more{to="/docs/api/composables/use-lazy-async-data"}
Read more about `useLazyAsyncData`.
::

:video-accordion{title="Watch a video from Vue School on blocking vs. non-blocking (lazy) requests" videoId="1022000555" platform="vimeo"}

### Client-only fetching

Theo mặc định, data fetching composable sẽ thực hiện asynchronous function của chúng trên cả môi trường client và server. Đặt tùy chọn `server` thành `false` để chỉ thực hiện call trên client-side. Trên initial load, data sẽ không được fetched trước khi hydration hoàn thành vì vậy bạn phải xử lý pending state, mặc dù trên subsequent client-side navigation, data sẽ được awaited trước khi load trang.

Kết hợp với tùy chọn `lazy`, điều này có thể hữu ích cho data không cần thiết trên render đầu tiên (ví dụ, data không nhạy cảm với SEO).

```ts twoslash
/* Call này được thực hiện trước hydration */
const articles = await useFetch('/api/article')

/* Call này sẽ chỉ được thực hiện trên client */
const { status, data: comments } = useFetch('/api/comments', {
  lazy: true,
  server: false
})
```

Composable `useFetch` được dành để được gọi trong setup method hoặc gọi trực tiếp ở cấp độ top của một hàm trong lifecycle hooks, nếu không bạn nên sử dụng [phương thức `$fetch`](#fetch).

### Minimize payload size

Tùy chọn `pick` giúp bạn giảm thiểu kích thước payload được lưu trữ trong tài liệu HTML bằng cách chỉ chọn các field mà bạn muốn trả về từ các composable.

```vue
<script setup lang="ts">
/* chỉ pick các field được sử dụng trong template của bạn */
const { data: mountain } = await useFetch('/api/mountains/everest', {
  pick: ['title', 'description']
})
</script>

<template>
  <h1>{{ mountain.title }}</h1>
  <p>{{ mountain.description }}</p>
</template>
```

Nếu bạn cần nhiều kiểm soát hơn hoặc map qua nhiều object, bạn có thể sử dụng hàm `transform` để thay đổi kết quả của query.

```ts
const { data: mountains } = await useFetch('/api/mountains', {
  transform: (mountains) => {
    return mountains.map(mountain => ({ title: mountain.title, description: mountain.description }))
  }
})
```

::note
Cả `pick` và `transform` không ngăn unwanted data được fetched ban đầu. Nhưng chúng sẽ ngăn unwanted data được thêm vào payload chuyển từ server đến client.
::

:video-accordion{title="Watch a video from Vue School on minimizing payload size" videoId="1026410430" platform="vimeo"}

### Caching and refetching

#### Keys

[`useFetch`](/docs/api/composables/use-fetch) và [`useAsyncData`](/docs/api/composables/use-async-data) sử dụng keys để ngăn refetching cùng data.

- [`useFetch`](/docs/api/composables/use-fetch) sử dụng URL được cung cấp làm key. Hoặc, một giá trị `key` có thể được cung cấp trong object `options` được truyền như đối số cuối cùng.
- [`useAsyncData`](/docs/api/composables/use-async-data) sử dụng đối số đầu tiên của nó làm key nếu nó là một chuỗi. Nếu đối số đầu tiên là handler function thực hiện query, thì một key duy nhất cho file name và line number của instance `useAsyncData` sẽ được tạo cho bạn.

::tip
Để lấy cached data theo key, bạn có thể sử dụng [`useNuxtData`](/docs/api/composables/use-nuxt-data)
::

:video-accordion{title="Watch a video from Vue School on caching data with the key option" videoId="1026410044" platform="vimeo"}

#### Shared State and Option Consistency

Khi nhiều component sử dụng cùng key với `useAsyncData` hoặc `useFetch`, chúng sẽ chia sẻ cùng `data`, `error` và `status` refs. Điều này đảm bảo tính nhất quán giữa các component nhưng yêu cầu một số tùy chọn phải nhất quán.

Các tùy chọn sau **phải nhất quán** trên tất cả các call với cùng key:
- hàm `handler`
- tùy chọn `deep`
- hàm `transform`
- mảng `pick`
- hàm `getCachedData`
- giá trị `default`

```ts
// ❌ Điều này sẽ kích hoạt warning phát triển
const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { deep: false })
const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { deep: true })
```

Các tùy chọn sau **có thể khác nhau một cách an toàn** mà không kích hoạt warning:
- `server`
- `lazy`
- `immediate`
- `dedupe`
- `watch`

```ts
// ✅ Điều này được phép
const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { immediate: true })
const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { immediate: false })
```

Nếu bạn cần các instance độc lập, sử dụng các key khác nhau:

```ts
// Đây là các instance hoàn toàn độc lập
const { data: users1 } = useAsyncData('users-1', () => $fetch('/api/users'))
const { data: users2 } = useAsyncData('users-2', () => $fetch('/api/users'))
```

#### Reactive Keys

Bạn có thể sử dụng computed refs, plain refs hoặc getter functions làm keys, cho phép dynamic data fetching tự động cập nhật khi dependencies thay đổi:

```ts
// Sử dụng computed property làm key
const userId = ref('123')
const { data: user } = useAsyncData(
  computed(() => `user-${userId.value}`),
  () => fetchUser(userId.value)
)

// Khi userId thay đổi, data sẽ tự động được refetched
// và old data sẽ được dọn dẹp nếu không có component nào khác sử dụng nó
userId.value = '456'
```

#### Refresh and execute

Nếu bạn muốn fetch hoặc refresh data một cách thủ công, hãy sử dụng hàm `execute` hoặc `refresh` được cung cấp bởi các composable.

```vue twoslash
<script setup lang="ts">
const { data, error, execute, refresh } = await useFetch('/api/users')
</script>

<template>
  <div>
    <p>{{ data }}</p>
    <button @click="() => refresh()">Refresh data</button>
  </div>
</template>
```

Hàm `execute` là một alias cho `refresh` hoạt động hoàn toàn giống nhau nhưng có tính semantic hơn cho các trường hợp khi fetch [không immediate](#not-immediate).

::tip
Để globally refetch hoặc invalidate cached data, xem [`clearNuxtData`](/docs/api/utils/clear-nuxt-data) và [`refreshNuxtData`](/docs/api/utils/refresh-nuxt-data).
::

#### Clear

Nếu bạn muốn clear data được cung cấp, vì bất kỳ lý do gì, mà không cần biết key cụ thể để truyền cho `clearNuxtData`, bạn có thể sử dụng hàm `clear` được cung cấp bởi các composable.

```vue twoslash
<script setup lang="ts">
const { data, clear } = await useFetch('/api/users')

const route = useRoute()
watch(() => route.path, (path) => {
  if (path === '/') clear()
})
</script>
```

#### Watch

Để re-run fetching function mỗi khi các reactive values khác trong ứng dụng thay đổi, hãy sử dụng tùy chọn `watch`. Bạn có thể sử dụng nó cho một hoặc nhiều elements _watchable_.

```vue twoslash
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch('/api/users', {
  /* Thay đổi id sẽ kích hoạt refetch */
  watch: [id]
})
</script>
```

Lưu ý rằng **watching một reactive value sẽ không thay đổi URL được fetched**. Ví dụ, điều này sẽ tiếp tục fetching cùng ID ban đầu của user bởi vì URL được xây dựng tại thời điểm hàm được gọi.

```vue
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch(`/api/users/${id.value}`, {
  watch: [id]
})
</script>
```

Nếu bạn cần thay đổi URL dựa trên một reactive value, bạn có thể muốn sử dụng một [computed URL](#computed-url) thay thế.

#### Computed URL

Đôi khi bạn cần tính toán một URL từ các giá trị reactive, và làm mới dữ liệu mỗi khi các giá trị đó thay đổi. Thay vì phải xử lý phức tạp, bạn có thể gắn trực tiếp từng tham số như một giá trị reactive. Nuxt sẽ tự động sử dụng giá trị reactive và re-fetch mỗi khi nó thay đổi.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch('/api/user', {
  query: {
    user_id: id
  }
})
</script>
```

Trong trường hợp việc xây dựng URL phức tạp hơn, bạn có thể dùng callback như một [computed getter](https://vuejs.org/guide/essentials/computed.html) để trả về chuỗi URL.

Mỗi khi một dependency thay đổi, dữ liệu sẽ được fetch bằng URL mới. Kết hợp với [not-immediate](#not-immediate), bạn có thể chờ đến khi phần tử reactive thay đổi mới tiến hành fetch.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch(() => `/api/users/${id.value}`, {
  immediate: false
})

const pending = computed(() => status.value === 'pending');
</script>

<template>
  <div>
    <!-- disable the input while fetching -->
    <input v-model="id" type="number" :disabled="pending"/>

    <div v-if="status === 'idle'">
      Type an user ID
    </div>

    <div v-else-if="pending">
      Loading ...
    </div>

    <div v-else>
      {{ data }}
    </div>
  </div>
</template>
```

Nếu bạn cần ép buộc refresh khi các giá trị reactive khác thay đổi, bạn cũng có thể [watch các giá trị khác](#watch).

### Not immediate

Composable `useFetch` sẽ bắt đầu fetch dữ liệu ngay khi được gọi. Bạn có thể ngăn việc này bằng cách đặt `immediate: false`, ví dụ, để chờ người dùng tương tác.

Với cách này, bạn cần cả `status` để xử lý vòng đời fetch, và `execute` để bắt đầu fetch dữ liệu.

```vue
<script setup lang="ts">
const { data, error, execute, status } = await useLazyFetch('/api/comments', {
  immediate: false
})
</script>

<template>
  <div v-if="status === 'idle'">
    <button @click="execute">Get data</button>
  </div>

  <div v-else-if="status === 'pending'">
    Loading comments...
  </div>

  <div v-else>
    {{ data }}
  </div>
</template>
```

Để kiểm soát chi tiết hơn, biến `status` có thể là:

* `idle` khi fetch chưa bắt đầu
* `pending` khi fetch đã bắt đầu nhưng chưa hoàn tất
* `error` khi fetch thất bại
* `success` khi fetch hoàn tất thành công

## Passing Headers and Cookies

Khi gọi `$fetch` trong browser, các header của người dùng như `cookie` sẽ được gửi trực tiếp đến API.

Thông thường, trong quá trình server-side-rendering, vì lý do bảo mật, `$fetch` sẽ không bao gồm cookie của browser, cũng như không truyền cookie từ phản hồi fetch.

Tuy nhiên, khi gọi `useFetch` với URL tương đối trên server, Nuxt sẽ sử dụng [`useRequestFetch`](/docs/api/composables/use-request-fetch) để proxy headers và cookies (ngoại trừ các header không nên chuyển tiếp như `host`).

### Pass Cookies From Server-side API Calls on SSR Response

Nếu bạn muốn truyền/proxy cookies theo hướng ngược lại, từ một request nội bộ trả về client, bạn cần tự xử lý.

```ts [composables/fetch.ts]
import { appendResponseHeader } from 'h3'
import type { H3Event } from 'h3'

export const fetchWithCookie = async (event: H3Event, url: string) => {
  /* Get the response from the server endpoint */
  const res = await $fetch.raw(url)
  /* Get the cookies from the response */
  const cookies = res.headers.getSetCookie()
  /* Attach each cookie to our incoming Request */
  for (const cookie of cookies) {
    appendResponseHeader(event, 'set-cookie', cookie)
  }
  /* Return the data of the response */
  return res._data
}
```

```vue
<script setup lang="ts">
// This composable will automatically pass cookies to the client
const event = useRequestEvent()

const { data: result } = await useAsyncData(() => fetchWithCookie(event!, '/api/with-cookie'))

onMounted(() => console.log(document.cookie))
</script>
```

## Options API Support

Nuxt cung cấp cách thực hiện `asyncData` fetching trong Options API. Bạn phải bọc định nghĩa component bằng `defineNuxtComponent` để nó hoạt động.

```vue
<script>
export default defineNuxtComponent({
  /* Use the fetchKey option to provide a unique key */
  fetchKey: 'hello',
  async asyncData () {
    return {
      hello: await $fetch('/api/hello')
    }
  }
})
</script>
```

::note
Sử dụng `<script setup>` hoặc `<script setup lang="ts">` là cách khuyến nghị để khai báo Vue component trong Nuxt.
::

:read-more{to="/docs/api/utils/define-nuxt-component"}

## Serializing Data From Server to Client

Khi dùng `useAsyncData` và `useLazyAsyncData` để truyền dữ liệu fetch từ server sang client (cũng như các trường hợp khác sử dụng [Nuxt payload](/docs/api/composables/use-nuxt-app#payload)), payload sẽ được serialize bằng [`devalue`](https://github.com/Rich-Harris/devalue). Điều này cho phép truyền không chỉ JSON cơ bản mà còn serialize/deserialize các loại dữ liệu nâng cao như regular expressions, Dates, Map, Set, `ref`, `reactive`, `shallowRef`, `shallowReactive` và `NuxtError`, v.v.

Bạn cũng có thể định nghĩa serializer/deserializer riêng cho các kiểu dữ liệu mà Nuxt không hỗ trợ. Tham khảo thêm trong tài liệu [`useNuxtApp`](/docs/api/composables/use-nuxt-app#payload).

Lưu ý rằng điều này *không áp dụng* cho dữ liệu được trả về từ server routes khi fetch bằng `$fetch` hoặc `useFetch` – xem phần tiếp theo để biết thêm chi tiết.
::

## Serializing Data From API Routes

Khi fetch dữ liệu từ thư mục `server`, response sẽ được serialize bằng `JSON.stringify`. Tuy nhiên, do giới hạn của việc serialize chỉ với các kiểu primitive của JavaScript, Nuxt sẽ cố gắng chuyển đổi giá trị trả về của `$fetch` và [`useFetch`](/docs/api/composables/use-fetch) sao cho khớp với giá trị thực.

Tìm hiểu thêm về giới hạn của `JSON.stringify`.
::

### Example

```ts [server/api/foo.ts]
export default defineEventHandler(() => {
  return new Date()
})
```

```vue [app.vue]
<script setup lang="ts">
// Type of `data` is inferred as string even though we returned a Date object
const { data } = await useFetch('/api/foo')
</script>
```

### Custom serializer function

Để tùy chỉnh hành vi serialize, bạn có thể định nghĩa hàm `toJSON` trong object được trả về. Nếu có `toJSON`, Nuxt sẽ sử dụng kết quả của hàm đó và không cố gắng chuyển đổi kiểu nữa.

```ts [server/api/bar.ts]
export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    toJSON() {
      return {
        createdAt: {
          year: this.createdAt.getFullYear(),
          month: this.createdAt.getMonth(),
          day: this.createdAt.getDate(),
        },
      }
    },
  }
  return data
})
```

```vue [app.vue]
<script setup lang="ts">
// Type of `data` is inferred as
// {
//   createdAt: {
//     year: number
//     month: number
//     day: number
//   }
// }
const { data } = await useFetch('/api/bar')
</script>
```

### Using an alternative serializer

Nuxt hiện chưa hỗ trợ serializer thay thế cho `JSON.stringify`. Tuy nhiên, bạn có thể trả payload dưới dạng chuỗi bình thường và dùng `toJSON` để giữ an toàn kiểu dữ liệu.

Ví dụ dưới đây sử dụng [superjson](https://github.com/blitz-js/superjson) làm serializer.

```ts [server/api/superjson.ts]
import superjson from 'superjson'

export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    // Workaround the type conversion
    toJSON() {
      return this
    }
  }

  // Serialize the output to string, using superjson
  return superjson.stringify(data) as unknown as typeof data
})
```

```vue [app.vue]
<script setup lang="ts">
import superjson from 'superjson'

// `date` is inferred as { createdAt: Date } and you can safely use the Date object methods
const { data } = await useFetch('/api/superjson', {
  transform: (value) => {
    return superjson.parse(value as unknown as string)
  },
})
</script>
```

## Recipes

### Consuming SSE (Server-Sent Events) via POST request

::tip
Nếu bạn dùng SSE qua GET request, bạn có thể sử dụng [`EventSource`](https://developer.mozilla.org/en-US/docs/Web/API/EventSource) hoặc VueUse composable [`useEventSource`](https://vueuse.org/core/useEventSource/).
::

Khi dùng SSE qua POST request, bạn cần tự xử lý kết nối. Ví dụ:

```ts
// Make a POST request to the SSE endpoint
const response = await $fetch<ReadableStream>('/chats/ask-ai', {
  method: 'POST',
  body: {
    query: "Hello AI, how are you?",
  },
  responseType: 'stream',
})

// Create a new ReadableStream from the response with TextDecoderStream to get the data as text
const reader = response.pipeThrough(new TextDecoderStream()).getReader()

// Read the chunk of data as we get it
while (true) {
  const { value, done } = await reader.read()

  if (done)
    break

  console.log('Received:', value)
}
```

### Making parallel requests

Khi các request không phụ thuộc lẫn nhau, bạn có thể chạy song song bằng `Promise.all()` để cải thiện hiệu năng.

```ts
const { data } = await useAsyncData(() => {
  return Promise.all([
    $fetch("/api/comments/"), 
    $fetch("/api/author/12")
  ]);
});

const comments = computed(() => data.value?.[0]);
const author = computed(() => data.value?.[1]);
```

:video-accordion{title="Watch a video from Vue School on parallel data fetching" videoId="1024262536" platform="vimeo"}
