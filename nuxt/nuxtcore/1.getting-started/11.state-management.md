---
title: 'State Management'
description: Nuxt cung cấp các thư viện quản lý state mạnh mẽ và composable useState để tạo ra một shared state phản ứng và thân thiện với SSR.
navigation.icon: i-lucide-database
---

Nuxt cung cấp composable [`useState`](/docs/api/composables/use-state) để tạo ra một shared state phản ứng và thân thiện với SSR qua các component.

[`useState`](/docs/api/composables/use-state) là một thay thế thân thiện với SSR cho [`ref`](https://vuejs.org/api/reactivity-core.html#ref). Giá trị của nó sẽ được bảo toàn sau server-side rendering (trong quá trình client-side hydration) và được chia sẻ qua tất cả các component sử dụng một key duy nhất.

:video-accordion{title="Xem video từ Alexander Lichter về tại sao và khi nào nên sử dụng useState" videoId="mv0WcBABcIk"}

::important
Vì dữ liệu bên trong [`useState`](/docs/api/composables/use-state) sẽ được serialize thành JSON, điều quan trọng là nó không được chứa bất cứ thứ gì không thể serialize được, chẳng hạn như class, function hoặc symbol.
::

::read-more{to="/docs/api/composables/use-state"}
Đọc thêm về composable `useState`.
::

## Best Practices

::warning
Không bao giờ định nghĩa `const state = ref()` bên ngoài `<script setup>` hoặc function `setup()`.<br>
Ví dụ, việc làm `export myState = ref({})` sẽ dẫn đến state được chia sẻ qua các request trên server và có thể gây ra memory leak.
::

::tip{icon="i-lucide-circle-check"}
Thay vào đó hãy sử dụng `const useX = () => useState('x')`
::

## Examples

### Basic Usage

Trong ví dụ này, chúng ta sử dụng một counter state cục bộ của component. Bất kỳ component nào khác sử dụng `useState('counter')` sẽ chia sẻ cùng một reactive state.

```vue twoslash [app.vue]
<script setup lang="ts">
const counter = useState('counter', () => Math.round(Math.random() * 1000))
</script>

<template>
  <div>
    Counter: {{ counter }}
    <button @click="counter++">
      +
    </button>
    <button @click="counter--">
      -
    </button>
  </div>
</template>
```

:link-example{to="/docs/examples/features/state-management"}

::note
Để vô hiệu hóa cached state toàn cục, xem util [`clearNuxtState`](/docs/api/utils/clear-nuxt-state).
::

### Initializing State

Hầu hết thời gian, bạn sẽ muốn khởi tạo state của mình với dữ liệu resolve bất đồng bộ. Bạn có thể sử dụng component [`app.vue`](/docs/guide/directory-structure/app) với util [`callOnce`](/docs/api/utils/call-once) để làm điều này.

```vue twoslash [app.vue]
<script setup lang="ts">
const websiteConfig = useState('config')

await callOnce(async () => {
  websiteConfig.value = await $fetch('https://my-cms.com/api/website-config')
})
</script>
```

::tip
Điều này tương tự như [`nuxtServerInit` action](https://v2.nuxt.com/docs/directory-structure/store/#the-nuxtserverinit-action) trong Nuxt 2, cho phép điền initial state của store ở phía server trước khi render trang.
::

:read-more{to="/docs/api/utils/call-once"}

### Usage with Pinia

Trong ví dụ này, chúng ta tận dụng [Pinia module](/modules/pinia) để tạo một global store và sử dụng nó trong toàn bộ app.

::important
Hãy chắc chắn cài đặt Pinia module với `npx nuxt module add pinia` hoặc làm theo [các bước cài đặt của module](https://pinia.vuejs.org/ssr/nuxt.html#Installation).
::

::code-group
```ts [stores/website.ts]
export const useWebsiteStore = defineStore('websiteStore', {
  state: () => ({
    name: '',
    description: ''
  }),
  actions: {
    async fetch() {
      const infos = await $fetch('https://api.nuxt.com/modules/pinia')

      this.name = infos.name
      this.description = infos.description
    }
  }
})
```
```vue [app.vue]
<script setup lang="ts">
const website = useWebsiteStore()

await callOnce(website.fetch)
</script>

<template>
  <main>
    <h1>{{ website.name }}</h1>
    <p>{{ website.description }}</p>
  </main>
</template>
```
::

## Advanced Usage

::code-group
```ts [composables/locale.ts]
import type { Ref } from 'vue'

export const useLocale = () => {
  return useState<string>('locale', () => useDefaultLocale().value)
}

export const useDefaultLocale = (fallback = 'en-US') => {
  const locale = ref(fallback)
  if (import.meta.server) {
    const reqLocale = useRequestHeaders()['accept-language']?.split(',')[0]
    if (reqLocale) {
      locale.value = reqLocale
    }
  } else if (import.meta.client) {
    const navLang = navigator.language
    if (navLang) {
      locale.value = navLang
    }
  }
  return locale
}

export const useLocales = () => {
  const locale = useLocale()
  const locales = ref([
    'en-US',
    'en-GB',
    ...
    'ja-JP-u-ca-japanese'
  ])
  if (!locales.value.includes(locale.value)) {
    locales.value.unshift(locale.value)
  }
  return locales
}

export const useLocaleDate = (date: Ref<Date> | Date, locale = useLocale()) => {
  return computed(() => new Intl.DateTimeFormat(locale.value, { dateStyle: 'full' }).format(unref(date)))
}
```

```vue [app.vue]
<script setup lang="ts">
const locales = useLocales()
const locale = useLocale()
const date = useLocaleDate(new Date('2016-10-26'))
</script>

<template>
  <div>
    <h1>Nuxt birthday</h1>
    <p>{{ date }}</p>
    <label for="locale-chooser">Xem trước một locale khác</label>
    <select id="locale-chooser" v-model="locale">
      <option v-for="locale of locales" :key="locale" :value="locale">
        {{ locale }}
      </option>
    </select>
  </div>
</template>
```
::

:link-example{to="/docs/examples/advanced/locale"}

## Shared State

Bằng cách sử dụng [auto-imported composables](/docs/guide/directory-structure/composables), chúng ta có thể định nghĩa các global state type-safe và import chúng trong toàn bộ app.

```ts twoslash [composables/states.ts]
export const useColor = () => useState<string>('color', () => 'pink')
```

```vue [app.vue]
<script setup lang="ts">
// ---cut-start---
const useColor = () => useState<string>('color', () => 'pink')
// ---cut-end---
const color = useColor() // Giống như useState('color')
</script>

<template>
  <p>Màu hiện tại: {{ color }}</p>
</template>
```

:video-accordion{title="Xem video từ Daniel Roe về cách xử lý global state và SSR trong Nuxt" videoId="dZSNW07sO-A"}

## Using third-party libraries

Nuxt **đã từng dựa vào** thư viện Vuex để cung cấp quản lý global state. Nếu bạn đang migration từ Nuxt 2, vui lòng tham khảo [hướng dẫn migration](/docs/migration/configuration#vuex).

Nuxt không có quan điểm cố định về quản lý state, vì vậy hãy thoải mái chọn giải pháp phù hợp với nhu cầu của bạn. Có nhiều tích hợp với các thư viện quản lý state phổ biến nhất, bao gồm:

- [Pinia](/modules/pinia) - khuyến nghị chính thức của Vue
- [Harlem](/modules/harlem) - quản lý immutable global state
- [XState](/modules/xstate) - phương pháp state machine với các công cụ để visualize và test logic state của bạn